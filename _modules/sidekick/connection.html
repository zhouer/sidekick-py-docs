

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sidekick.connection &mdash; Sidekick Python Library 0.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=47de8214"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Sidekick Python Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">sidekick</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/zhouer/Sidekick">GitHub Repository</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/sidekick-py/">PyPI Package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Sidekick Python Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sidekick.connection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sidekick.connection</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Manages the WebSocket connection between your Python script and the Sidekick UI.</span>

<span class="sd">This module is the heart of the communication layer. It handles the tricky bits</span>
<span class="sd">of talking to the Sidekick panel running in VS Code, letting your Python script</span>
<span class="sd">send commands (like &quot;create a grid&quot; or &quot;set a color&quot;) and receive events</span>
<span class="sd">(like &quot;button clicked&quot; or &quot;text entered&quot;).</span>

<span class="sd">How it Works (The Short Version):</span>
<span class="sd">- It uses WebSockets to talk to a server running inside the Sidekick VS Code extension.</span>
<span class="sd">- The *first* time your script tries to interact with Sidekick (e.g., creating</span>
<span class="sd">  a `sidekick.Grid()`), this module tries to connect.</span>
<span class="sd">- **Important:** It will PAUSE (block) your script until the connection is fully</span>
<span class="sd">  ready (connected to the server AND the Sidekick UI panel confirms it&#39;s ready).</span>
<span class="sd">- If it can&#39;t connect or the UI doesn&#39;t respond in time, it raises an error.</span>
<span class="sd">- Once connected, sending commands happens immediately.</span>
<span class="sd">- A background &quot;listener&quot; thread waits for messages (like clicks) from the UI.</span>
<span class="sd">- If the connection breaks, it raises an error; it won&#39;t try to reconnect automatically.</span>

<span class="sd">You usually interact with this module indirectly through functions like</span>
<span class="sd">`sidekick.run_forever()` or `sidekick.shutdown()`, or just by creating and</span>
<span class="sd">using the visual module classes (`Grid`, `Console`, etc.).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">websocket</span> <span class="c1"># The library used for WebSocket communication (websocket-client)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">atexit</span> <span class="c1"># Used to automatically call shutdown() when the script exits</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Set</span>

<span class="c1"># --- Import logger and Version ---</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">logger</span> <span class="c1"># Use the central logger defined in __init__.py</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Try to get the version number from the _version.py file</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">._version</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># If _version.py isn&#39;t found (e.g., during development setup), use a fallback.</span>
    <span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>

<span class="c1"># --- Custom Exceptions ---</span>
<span class="c1"># Define specific error types for connection problems, making it easier</span>
<span class="c1"># for users to catch and potentially handle different failure scenarios.</span>

<div class="viewcode-block" id="SidekickConnectionError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickConnectionError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickConnectionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base error for all Sidekick connection-related problems.</span>

<span class="sd">    You can use `except sidekick.SidekickConnectionError:` to catch any</span>
<span class="sd">    connection issue raised by the library.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SidekickConnectionRefusedError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickConnectionRefusedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the library fails to connect to the Sidekick server initially.</span>

<span class="sd">    This usually means:</span>
<span class="sd">    1. The Sidekick panel isn&#39;t open in VS Code.</span>
<span class="sd">    2. The Sidekick VS Code extension isn&#39;t running correctly.</span>
<span class="sd">    3. The WebSocket server couldn&#39;t start (maybe the port is already in use,</span>
<span class="sd">       check VS Code&#39;s &quot;Sidekick Server&quot; output channel).</span>
<span class="sd">    4. A firewall is blocking the connection.</span>
<span class="sd">    5. The URL configured via `sidekick.set_url()` is incorrect.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        url (str): The WebSocket URL that the connection attempt was made to.</span>
<span class="sd">        original_exception (Exception): The lower-level error that caused the failure</span>
<span class="sd">            (e.g., `ConnectionRefusedError`, `TimeoutError`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_exception</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_exception</span> <span class="o">=</span> <span class="n">original_exception</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Failed to connect to Sidekick server at </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Reason: </span><span class="si">{</span><span class="n">original_exception</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Is the Sidekick panel open in VS Code? &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Check the URL, port conflicts, and firewall.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SidekickTimeoutError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickTimeoutError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickTimeoutError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the connection to the server succeeded, but the Sidekick UI didn&#39;t respond in time.</span>

<span class="sd">    After connecting to the WebSocket server (run by the VS Code extension),</span>
<span class="sd">    the library waits for the Sidekick UI panel (the React app in the webview)</span>
<span class="sd">    to send a message saying it&#39;s ready (`system/announce`). If this message</span>
<span class="sd">    doesn&#39;t arrive within a few seconds, this error occurs.</span>

<span class="sd">    This might happen if:</span>
<span class="sd">    1. The Sidekick panel is open but hasn&#39;t finished loading its content yet.</span>
<span class="sd">    2. There&#39;s an error within the Sidekick UI panel itself (check the</span>
<span class="sd">       Webview Developer Tools in VS Code for errors).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        timeout (float): The number of seconds the library waited for the UI response.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Connected to server, but timed out after </span><span class="si">{</span><span class="n">timeout</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> seconds waiting &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;for the Sidekick UI panel to signal it&#39;s ready. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Is the panel visible and fully loaded in VS Code?&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SidekickDisconnectedError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickDisconnectedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickDisconnectedError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the connection is lost *after* it was successfully established.</span>

<span class="sd">    This indicates that communication was working, but something interrupted it.</span>
<span class="sd">    Possible causes include:</span>
<span class="sd">    1. The Sidekick panel was closed in VS Code.</span>
<span class="sd">    2. The Sidekick VS Code extension crashed or was stopped.</span>
<span class="sd">    3. A network interruption occurred between the Python script and VS Code.</span>
<span class="sd">    4. An error occurred while trying to send or receive a message.</span>

<span class="sd">    **Important:** The library will **not** automatically try to reconnect.</span>
<span class="sd">    Subsequent attempts to send messages will also fail unless the connection</span>
<span class="sd">    is manually re-established (which typically involves restarting the script).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        reason (str): A short description of why the disconnection occurred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Connection lost&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reason</span> <span class="o">=</span> <span class="n">reason</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sidekick connection lost: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The connection was active but is now broken. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The library will not automatically reconnect.&quot;</span>
        <span class="p">)</span></div>


<span class="c1"># --- Connection Status Enum ---</span>
<div class="viewcode-block" id="ConnectionStatus">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.ConnectionStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConnectionStatus</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents the different states of the WebSocket connection.&quot;&quot;&quot;</span>
    <span class="n">DISCONNECTED</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>               <span class="c1"># Default state, or after closing/error.</span>
    <span class="n">CONNECTING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>                 <span class="c1"># Trying to establish the WebSocket link.</span>
    <span class="n">CONNECTED_WAITING_SIDEKICK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span> <span class="c1"># Link established, waiting for UI &#39;ready&#39; signal.</span>
    <span class="n">CONNECTED_READY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># Everything is connected and ready for messages.</span></div>


<span class="c1"># --- Configuration and State (Internal Variables) ---</span>
<span class="c1"># These variables store the connection details and current state.</span>
<span class="c1"># They are considered internal and might change in future versions.</span>

<span class="c1"># The URL to connect to. Can be changed using sidekick.set_url() *before* connecting.</span>
<span class="n">_ws_url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ws://localhost:5163&quot;</span>
<span class="c1"># Holds the active WebSocket connection object once established.</span>
<span class="n">_ws_connection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocket</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># A lock to prevent race conditions when multiple threads access connection state.</span>
<span class="n">_connection_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
<span class="c1"># The background thread that listens for incoming messages from Sidekick.</span>
<span class="n">_listener_thread</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># Flag to track if the listener thread has been started for the current connection attempt.</span>
<span class="n">_listener_started</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># A dictionary mapping module instance IDs (e.g., &quot;grid-1&quot;) to the function</span>
<span class="c1"># that should handle messages for that specific instance.</span>
<span class="n">_message_handlers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># A simple counter used by sidekick.Canvas to generate unique command IDs.</span>
<span class="n">_command_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># A unique ID generated for this specific run of the Python script (&quot;Hero&quot;).</span>
<span class="n">_peer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># Tracks the current status of the connection using the ConnectionStatus enum.</span>
<span class="n">_connection_status</span><span class="p">:</span> <span class="n">ConnectionStatus</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
<span class="c1"># Stores the peer IDs of Sidekick UI instances that have announced they are online.</span>
<span class="n">_sidekick_peers_online</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="c1"># Configuration flags (set via sidekick.set_config).</span>
<span class="n">_clear_on_connect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">_clear_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># An optional global handler (for debugging) that receives *all* messages.</span>
<span class="n">_global_message_handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># --- Threading Events for Synchronization ---</span>
<span class="c1"># These events are used to coordinate between the main script thread,</span>
<span class="c1"># the listener thread, and shutdown procedures.</span>
<span class="c1"># Signals the listener thread that it should stop running.</span>
<span class="n">_stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
<span class="c1"># Set by the listener thread when the connection becomes CONNECTED_READY.</span>
<span class="c1"># activate_connection() waits on this event.</span>
<span class="n">_ready_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
<span class="c1"># Set by shutdown() or Ctrl+C to signal run_forever() to exit cleanly.</span>
<span class="n">_shutdown_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

<span class="c1"># --- Constants ---</span>
<span class="c1"># Timeouts and intervals used for connection and communication.</span>
<span class="n">_INITIAL_CONNECT_TIMEOUT</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="c1"># Max seconds to wait for the initial WebSocket connection.</span>
<span class="n">_SIDEKICK_WAIT_TIMEOUT</span> <span class="o">=</span> <span class="mf">2.0</span>   <span class="c1"># Max seconds to wait for the Sidekick UI &#39;online&#39; message.</span>
<span class="n">_LISTENER_RECV_TIMEOUT</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c1"># How long ws.recv() waits before timing out in the listener loop.</span>
                               <span class="c1"># This allows the loop to check _stop_event periodically.</span>
<span class="c1"># WebSocket Ping settings (helps detect dead connections)</span>
<span class="n">_PING_INTERVAL</span> <span class="o">=</span> <span class="mi">20</span>            <span class="c1"># Send a ping every 20 seconds.</span>
<span class="n">_PING_TIMEOUT</span> <span class="o">=</span> <span class="mi">10</span>             <span class="c1"># Wait max 10 seconds for pong reply.</span>

<span class="c1"># --- Private Helper Functions (Used only within this module) ---</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_generate_peer_id</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates or returns the unique ID for this Python script instance.&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_peer_id</span>
    <span class="c1"># Generate it only once per script run.</span>
    <span class="k">if</span> <span class="n">_peer_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_peer_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hero-</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generated Hero Peer ID: </span><span class="si">{</span><span class="n">_peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_peer_id</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">:</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocket</span><span class="p">,</span> <span class="n">message_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Safely sends a dictionary as a JSON string over the WebSocket.</span>

<span class="sd">    Handles JSON conversion and basic WebSocket send errors.</span>

<span class="sd">    Args:</span>
<span class="sd">        ws: The active WebSocket connection object.</span>
<span class="sd">        message_dict: The Python dictionary to send.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickDisconnectedError: If sending fails due to WebSocket issues</span>
<span class="sd">            (e.g., connection closed, broken pipe).</span>
<span class="sd">        Exception: For unexpected errors like JSON serialization problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Convert the Python dictionary to a JSON string.</span>
        <span class="n">message_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message_dict</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sending raw: </span><span class="si">{</span><span class="n">message_json</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Send the JSON string over the WebSocket.</span>
        <span class="n">ws</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message_json</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketException</span><span class="p">,</span> <span class="ne">BrokenPipeError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># These errors usually mean the connection is no longer valid.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WebSocket send error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Connection lost.&quot;</span><span class="p">)</span>
        <span class="c1"># Raise our specific error to indicate disconnection.</span>
        <span class="c1"># The calling function (send_message) will handle cleanup.</span>
        <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Send failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch other potential errors (e.g., json.dumps failure).</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error sending message: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Wrap unexpected errors too, treating them as a disconnect.</span>
        <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected send error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_send_system_announce</span><span class="p">(</span><span class="n">status</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a special &#39;system/announce&#39; message to the server.</span>

<span class="sd">    This tells the server (and other connected clients like the UI) that this</span>
<span class="sd">    Python script (&#39;hero&#39;) is now &#39;online&#39; or going &#39;offline&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        status (str): Either &quot;online&quot; or &quot;offline&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use the lock to safely access the shared connection object.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span> <span class="c1"># Get the current WebSocket object.</span>
        <span class="n">peer_id</span> <span class="o">=</span> <span class="n">_generate_peer_id</span><span class="p">()</span> <span class="c1"># Make sure we have our ID.</span>

        <span class="c1"># Check if we actually have a valid, connected WebSocket.</span>
        <span class="k">if</span> <span class="n">ws</span> <span class="ow">and</span> <span class="n">ws</span><span class="o">.</span><span class="n">connected</span> <span class="ow">and</span> <span class="n">peer_id</span><span class="p">:</span>
            <span class="n">announce_payload</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;peerId&quot;</span><span class="p">:</span> <span class="n">peer_id</span><span class="p">,</span>          <span class="c1"># Our unique ID.</span>
                <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;hero&quot;</span><span class="p">,</span>             <span class="c1"># We are the Python script.</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>           <span class="c1"># &#39;online&#39; or &#39;offline&#39;.</span>
                <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">__version__</span><span class="p">,</span>     <span class="c1"># Library version.</span>
                <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1"># Current time in ms.</span>
            <span class="p">}</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># Reserved, usually 0.</span>
                <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;system&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;announce&quot;</span><span class="p">,</span>
                <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">announce_payload</span>
            <span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Use the safe sending function.</span>
                <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sent system announce: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SidekickDisconnectedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># If sending the announce fails (e.g., during shutdown), log a</span>
                <span class="c1"># warning but don&#39;t crash the shutdown process itself.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not send system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error sending system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;offline&quot;</span><span class="p">:</span>
             <span class="c1"># It&#39;s okay if we can&#39;t send &#39;offline&#39; if we&#39;re already disconnected.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cannot send offline announce, connection already closed or closing.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="c1"># It&#39;s a problem if we try to send &#39;online&#39; but aren&#39;t connected.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot send system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39;, WebSocket not connected.&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_listen_for_messages</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The main function run by the background listener thread.</span>

<span class="sd">    It continuously waits for messages from the WebSocket server, parses them,</span>
<span class="sd">    and dispatches them to the appropriate handlers (either the global handler</span>
<span class="sd">    or a specific module instance&#39;s handler). It also updates connection state</span>
<span class="sd">    based on &#39;system/announce&#39; messages from the Sidekick UI.</span>

<span class="sd">    This function runs until `_stop_event` is set or the connection breaks.</span>
<span class="sd">    If the connection breaks unexpectedly, it triggers `close_connection` to</span>
<span class="sd">    clean up and potentially raise `SidekickDisconnectedError`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_connection_status</span><span class="p">,</span> <span class="n">_message_handlers</span><span class="p">,</span> <span class="n">_sidekick_peers_online</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_global_message_handler</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener thread started.&quot;</span><span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Listener thread terminated normally&quot;</span> <span class="c1"># Default exit reason</span>

    <span class="c1"># Keep looping as long as the stop signal hasn&#39;t been received.</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="c1"># --- Check Connection State Safely ---</span>
        <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
            <span class="c1"># If connection was closed externally, stop listening.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Status became DISCONNECTED&quot;</span>
                <span class="k">break</span>
            <span class="c1"># Ensure we still have a valid WebSocket object.</span>
            <span class="k">if</span> <span class="n">_ws_connection</span> <span class="ow">and</span> <span class="n">_ws_connection</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Connection object is gone or disconnected.</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocket connection lost unexpectedly&quot;</span>
                <span class="c1"># Only log a warning if this wasn&#39;t a planned stop.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket connection lost.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ws</span><span class="p">:</span>
            <span class="c1"># Should be redundant due to above check, but added safety.</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocket object is None&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket object is None, stopping loop.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># --- Receive Message ---</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Wait for a message, but time out after _LISTENER_RECV_TIMEOUT seconds.</span>
            <span class="c1"># This timeout allows the loop to check the _stop_event regularly.</span>
            <span class="n">ws</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="n">_LISTENER_RECV_TIMEOUT</span><span class="p">)</span>
            <span class="n">message_str</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

            <span class="c1"># Check again if stop was signaled *while* waiting for recv().</span>
            <span class="k">if</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Stop event set during receive&quot;</span>
                <span class="k">break</span>

            <span class="c1"># An empty message usually means the server closed the connection cleanly.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">message_str</span><span class="p">:</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Server closed connection (received empty message)&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener: Server closed connection.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received raw message: </span><span class="si">{</span><span class="n">message_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Parse the incoming JSON string into a Python dictionary.</span>
            <span class="n">message_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message_str</span><span class="p">)</span>

            <span class="c1"># --- Process Message Safely ---</span>
            <span class="c1"># Acquire the lock to prevent conflicts while handling the message</span>
            <span class="c1"># and potentially updating shared state (_connection_status, handlers).</span>
            <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
                <span class="c1"># Check status again inside the lock.</span>
                <span class="k">if</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c1"># Stop processing if we are stopping/disconnected.</span>

                <span class="c1"># --- 1. Global Handler ---</span>
                <span class="c1"># If a global handler is registered, call it first with the raw message.</span>
                <span class="k">if</span> <span class="n">_global_message_handler</span><span class="p">:</span>
                     <span class="k">try</span><span class="p">:</span>
                         <span class="n">_global_message_handler</span><span class="p">(</span><span class="n">message_data</span><span class="p">)</span>
                     <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Error in global message handler: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># --- 2. Message Dispatch ---</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">)</span>
                <span class="n">msg_type</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>
                <span class="n">payload</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;payload&#39;</span><span class="p">)</span>

                <span class="c1"># --- Handle System Announce (Sidekick UI Ready?) ---</span>
                <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s1">&#39;system&#39;</span> <span class="ow">and</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s1">&#39;announce&#39;</span> <span class="ow">and</span> <span class="n">payload</span><span class="p">:</span>
                    <span class="n">peer_id</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;peerId&#39;</span><span class="p">)</span>
                    <span class="n">role</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;role&#39;</span><span class="p">)</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">)</span>

                    <span class="c1"># Is this announcement from a Sidekick UI panel?</span>
                    <span class="k">if</span> <span class="n">peer_id</span> <span class="ow">and</span> <span class="n">role</span> <span class="o">==</span> <span class="s1">&#39;sidekick&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;online&#39;</span><span class="p">:</span>
                            <span class="c1"># A Sidekick UI just connected.</span>
                            <span class="n">was_empty</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">_sidekick_peers_online</span> <span class="c1"># Was this the *first* UI?</span>
                            <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">peer_id</span><span class="p">)</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick peer online: </span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                            <span class="c1"># If this IS the first UI and we were waiting...</span>
                            <span class="k">if</span> <span class="n">was_empty</span> <span class="ow">and</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_WAITING_SIDEKICK</span><span class="p">:</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First Sidekick UI &#39;</span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&#39; announced online. System is READY.&quot;</span><span class="p">)</span>
                                <span class="c1"># Update the status to READY!</span>
                                <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span>
                                <span class="c1"># If configured, send a &#39;clearAll&#39; command now.</span>
                                <span class="k">if</span> <span class="n">_clear_on_connect</span><span class="p">:</span>
                                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;clear_on_connect is True, sending global/clearAll.&quot;</span><span class="p">)</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="c1"># Can call directly now, connection assumed ready</span>
                                        <span class="n">clear_all</span><span class="p">()</span>
                                    <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e_clr</span><span class="p">:</span>
                                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to clearAll on connect: </span><span class="si">{</span><span class="n">e_clr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="c1"># IMPORTANT: Signal the main thread (waiting in activate_connection)</span>
                                <span class="c1"># that the connection is finally ready!</span>
                                <span class="n">_ready_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

                        <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;offline&#39;</span><span class="p">:</span>
                            <span class="c1"># A Sidekick UI disconnected.</span>
                            <span class="k">if</span> <span class="n">peer_id</span> <span class="ow">in</span> <span class="n">_sidekick_peers_online</span><span class="p">:</span>
                                <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">peer_id</span><span class="p">)</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick peer offline: </span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="c1"># Note: The connection remains READY even if all UIs leave.</span>
                                <span class="c1"># A disconnect error will only occur on the next send/receive</span>
                                <span class="c1"># attempt if the underlying WebSocket is actually closed.</span>

                <span class="c1"># --- Handle Module Event/Error (Dispatch to Instance) ---</span>
                <span class="k">elif</span> <span class="n">msg_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">]:</span>
                    <span class="c1"># These messages come FROM a specific UI module instance.</span>
                    <span class="c1"># The &#39;src&#39; field tells us which one.</span>
                    <span class="n">instance_id</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">instance_id</span> <span class="ow">and</span> <span class="n">instance_id</span> <span class="ow">in</span> <span class="n">_message_handlers</span><span class="p">:</span>
                        <span class="c1"># Find the handler function registered for this instance ID.</span>
                        <span class="n">handler</span> <span class="o">=</span> <span class="n">_message_handlers</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Invoking handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; (type: </span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
                             <span class="c1"># Call the instance&#39;s specific handler (e.g., Grid._internal_message_handler).</span>
                             <span class="n">handler</span><span class="p">(</span><span class="n">message_data</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                             <span class="c1"># Catch errors within the user&#39;s callback or the internal handler.</span>
                             <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Error executing handler for &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">instance_id</span><span class="p">:</span>
                        <span class="c1"># We received a message for an instance we don&#39;t know about</span>
                        <span class="c1"># (maybe it was already removed). Just log it.</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: No specific handler registered for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; for message type </span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># The message is missing the &#39;src&#39; ID, can&#39;t dispatch.</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received </span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2"> message without &#39;src&#39;: </span><span class="si">{</span><span class="n">message_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We received a message type we don&#39;t handle (e.g., &#39;spawn&#39; from UI).</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received unhandled message type: module=&#39;</span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s2">&#39;, type=&#39;</span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketTimeoutException</span><span class="p">:</span>
            <span class="c1"># This is expected because of ws.settimeout(). Just continue the loop.</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketConnectionClosedException</span><span class="p">:</span>
            <span class="c1"># The server explicitly closed the connection.</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocketConnectionClosedException&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket connection closed by server.&quot;</span><span class="p">)</span>
            <span class="k">break</span> <span class="c1"># Exit the loop.</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Received invalid JSON or unexpected data type.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Failed to parse JSON or invalid data: </span><span class="si">{</span><span class="n">message_str</span><span class="si">}</span><span class="s2">, Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span> <span class="c1"># Try to continue listening.</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Handle lower-level OS errors (network issues, etc.).</span>
            <span class="c1"># Ignore &quot;Bad file descriptor&quot; if we are already stopping (expected).</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="mi">9</span><span class="p">):</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;OS error (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                     <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: OS error (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">), likely connection closed.&quot;</span><span class="p">)</span>
                <span class="k">break</span> <span class="c1"># Exit the loop on OS errors.</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Catch any other unexpected error during the loop.</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unexpected error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Unexpected error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span> <span class="c1"># Exit the loop.</span>

    <span class="c1"># --- Listener Loop Exit ---</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener thread finished. Reason: </span><span class="si">{</span><span class="n">disconnect_reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Ensure the flag reflects that the listener is no longer running.</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># If the loop exited *unexpectedly* (not via _stop_event)...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener thread terminated unexpectedly. Initiating disconnect process.&quot;</span><span class="p">)</span>
        <span class="c1"># Trigger the cleanup process. This will likely lead to a</span>
        <span class="c1"># SidekickDisconnectedError being raised for the main thread.</span>
        <span class="c1"># Run close_connection in a new thread to avoid potential deadlocks.</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span>
            <span class="c1"># Mark as an exception, pass the reason.</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span>
            <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span> <span class="c1"># Don&#39;t let this cleanup thread block script exit.</span>
        <span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_connection</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal function to establish the initial WebSocket connection.</span>

<span class="sd">    Called by `activate_connection`. It attempts to connect to the server</span>
<span class="sd">    and starts the listener thread if successful.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the WebSocket connection fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_connection</span><span class="p">,</span> <span class="n">_listener_thread</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_connection_status</span>

    <span class="c1"># --- This function assumes _connection_lock is already held by the caller ---</span>

    <span class="c1"># Safety check: should only be called when DISCONNECTED.</span>
    <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_ensure_connection called when status is </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempting to connect to Sidekick server at </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
    <span class="c1"># --- Prepare for New Connection ---</span>
    <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTING</span>
    <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Reset known UI peers.</span>
    <span class="c1"># Reset threading events for this new attempt.</span>
    <span class="n">_stop_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">_ready_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c1"># --- Attempt Connection ---</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Create the WebSocket connection. This might block for up to</span>
        <span class="c1"># _INITIAL_CONNECT_TIMEOUT seconds.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="n">websocket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
            <span class="n">_ws_url</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">_INITIAL_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">ping_interval</span><span class="o">=</span><span class="n">_PING_INTERVAL</span><span class="p">,</span> <span class="c1"># Enable automatic pings</span>
            <span class="n">ping_timeout</span><span class="o">=</span><span class="n">_PING_TIMEOUT</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Successfully connected to Sidekick server.&quot;</span><span class="p">)</span>

        <span class="c1"># --- Connection Successful ---</span>
        <span class="c1"># Send our &#39;online&#39; announcement immediately.</span>
        <span class="n">_send_system_announce</span><span class="p">(</span><span class="s2">&quot;online&quot;</span><span class="p">)</span>
        <span class="c1"># Update status: We are connected, but waiting for the UI panel.</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_WAITING_SIDEKICK</span>

        <span class="c1"># Start the listener thread if it&#39;s not already running.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_listener_started</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_listener_thread</span> <span class="ow">and</span> <span class="n">_listener_thread</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting WebSocket listener thread.&quot;</span><span class="p">)</span>
            <span class="c1"># Create and start the thread. It&#39;s crucial to set daemon=True so</span>
            <span class="c1"># this background thread doesn&#39;t prevent the main script from exiting</span>
            <span class="c1"># if the main script finishes before sidekick.shutdown() is called.</span>
            <span class="n">_listener_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">_listen_for_messages</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">_listener_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">_listener_started</span><span class="p">:</span>
             <span class="c1"># Should not happen with correct state management.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener thread already marked as started during connect sequence (unexpected).&quot;</span><span class="p">)</span>

    <span class="c1"># --- Handle Connection Errors ---</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketException</span><span class="p">,</span> <span class="ne">ConnectionRefusedError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">TimeoutError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to connect to Sidekick server at </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Clean up state on failure.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span> <span class="c1"># Signal potential (failed) listener to stop.</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Raise the specific error for activate_connection to handle.</span>
        <span class="k">raise</span> <span class="n">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">_ws_url</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch any other unexpected errors during setup.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error during connection: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Wrap the error.</span>
        <span class="k">raise</span> <span class="n">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">_ws_url</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>


<span class="c1"># --- Public API Functions ---</span>
<span class="c1"># These functions are intended to be used directly by users of the library.</span>

<div class="viewcode-block" id="set_url">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.set_url">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sets the WebSocket URL where the Sidekick server is expected to be listening.</span>

<span class="sd">    **Important:** You **must** call this *before* creating any Sidekick modules</span>
<span class="sd">    (like `Grid`, `Console`) or trying to send any messages, as the first action</span>
<span class="sd">    will trigger the connection attempt using the currently set URL.</span>

<span class="sd">    If you call this after a connection attempt has already been made (even</span>
<span class="sd">    if it failed), it will log a warning and have no effect unless you call</span>
<span class="sd">    `sidekick.shutdown()` first to completely reset the connection state.</span>

<span class="sd">    Args:</span>
<span class="sd">        url (str): The full WebSocket URL, starting with &quot;ws://&quot; or &quot;wss://&quot;.</span>
<span class="sd">                   The default is &quot;ws://localhost:5163&quot;.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import sidekick</span>
<span class="sd">        &gt;&gt;&gt; # If your Sidekick server is running on a different port</span>
<span class="sd">        &gt;&gt;&gt; sidekick.set_url(&quot;ws://127.0.0.1:8000&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Now it&#39;s safe to create Sidekick modules</span>
<span class="sd">        &gt;&gt;&gt; console = sidekick.Console()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_url</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only allow changing the URL if we haven&#39;t even started connecting yet.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot change Sidekick URL after a connection attempt &quot;</span>
                           <span class="s2">&quot;has been made. Call sidekick.shutdown() first if needed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Simple validation.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&quot;ws://&quot;</span><span class="p">,</span> <span class="s2">&quot;wss://&quot;</span><span class="p">)):</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid WebSocket URL provided: &#39;</span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;It must start with &#39;ws://&#39; or &#39;wss://&#39;. Using default &#39;</span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
             <span class="k">return</span> <span class="c1"># Keep the existing default if invalid format provided</span>
        <span class="n">_ws_url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick WebSocket URL set to: </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_config">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.set_config">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_config</span><span class="p">(</span><span class="n">clear_on_connect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">clear_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configures automatic clearing of the Sidekick UI.</span>

<span class="sd">    **Important:** You **must** call this *before* creating any Sidekick modules</span>
<span class="sd">    or trying to send any messages. Like `set_url`, calling it after a connection</span>
<span class="sd">    attempt will have no effect unless `shutdown()` is called first.</span>

<span class="sd">    Args:</span>
<span class="sd">        clear_on_connect (bool): If True (the default), the library will send</span>
<span class="sd">            a command to clear *all* existing elements from the Sidekick UI</span>
<span class="sd">            as soon as the connection becomes fully ready (when the UI panel</span>
<span class="sd">            signals it&#39;s online). Set this to False if you want your script</span>
<span class="sd">            to potentially interact with UI elements left over from a previous</span>
<span class="sd">            script run (less common).</span>
<span class="sd">        clear_on_disconnect (bool): If True (default is False), the library</span>
<span class="sd">            will *attempt* to send a command to clear the Sidekick UI when</span>
<span class="sd">            your script disconnects cleanly (e.g., when `shutdown()` is called</span>
<span class="sd">            or the script ends normally). This is a &quot;best-effort&quot; attempt and</span>
<span class="sd">            might not succeed if the disconnection is abrupt or caused by an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_clear_on_connect</span><span class="p">,</span> <span class="n">_clear_on_disconnect</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only allow changing config if we haven&#39;t started connecting.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot change Sidekick config after a connection attempt &quot;</span>
                           <span class="s2">&quot;has been made. Call sidekick.shutdown() first if needed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">_clear_on_connect</span> <span class="o">=</span> <span class="n">clear_on_connect</span>
        <span class="n">_clear_on_disconnect</span> <span class="o">=</span> <span class="n">clear_on_disconnect</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick config set: clear_on_connect=</span><span class="si">{</span><span class="n">_clear_on_connect</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;clear_on_disconnect=</span><span class="si">{</span><span class="n">_clear_on_disconnect</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="activate_connection">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.activate_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">activate_connection</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures the connection to Sidekick is established and fully ready.</span>

<span class="sd">    This is the **key function** that guarantees the library is prepared for</span>
<span class="sd">    sending messages. It performs these steps:</span>

<span class="sd">    1. Checks the current connection status. If already `CONNECTED_READY`, it returns immediately.</span>
<span class="sd">    2. If `DISCONNECTED`, it calls the internal `_ensure_connection()` to:</span>
<span class="sd">       - Attempt the WebSocket connection to the server.</span>
<span class="sd">       - Start the background listener thread.</span>
<span class="sd">       - Send the initial &#39;online&#39; announcement.</span>
<span class="sd">    3. If the connection to the server succeeds (status becomes</span>
<span class="sd">       `CONNECTED_WAITING_SIDEKICK`), it then **pauses (blocks)** execution.</span>
<span class="sd">    4. It waits for the background listener thread to receive the &#39;online&#39;</span>
<span class="sd">       announcement from the Sidekick UI panel (which sets the `_ready_event`).</span>
<span class="sd">    5. Once the `_ready_event` is set and the status is `CONNECTED_READY`, this</span>
<span class="sd">       function returns, and the script can proceed.</span>

<span class="sd">    **When is it called?** This function is called automatically *before* any</span>
<span class="sd">    message is sent (e.g., by `grid.set_color`, `console.print`, `viz.show`, etc.)</span>
<span class="sd">    and also at the beginning of `sidekick.run_forever()`. You generally don&#39;t</span>
<span class="sd">    need to call it yourself unless you want to explicitly establish the</span>
<span class="sd">    connection at a specific point without immediately sending a command.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the initial WebSocket connection attempt fails.</span>
<span class="sd">        SidekickTimeoutError: If the Sidekick UI panel doesn&#39;t signal readiness within</span>
<span class="sd">                              the `_SIDEKICK_WAIT_TIMEOUT`.</span>
<span class="sd">        SidekickDisconnectedError: If the connection is lost while waiting for the</span>
<span class="sd">                                   UI panel or if the state is inconsistent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Acquire lock to check status and potentially start connection.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">current_status</span> <span class="o">=</span> <span class="n">_connection_status</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;activate_connection called. Current status: </span><span class="si">{</span><span class="n">current_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># If already ready, we&#39;re good to go!</span>
        <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection already READY.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># If disconnected, need to start the connection process.</span>
        <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># This internal function attempts connection and starts the listener.</span>
                <span class="c1"># It raises SidekickConnectionRefusedError on failure.</span>
                <span class="n">_ensure_connection</span><span class="p">()</span>
                <span class="c1"># If _ensure_connection succeeded, status is now CONNECTING or</span>
                <span class="c1"># CONNECTED_WAITING_SIDEKICK. Proceed to wait for the UI.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initial connection attempt successful, now waiting for UI readiness.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># If _ensure_connection failed, re-raise the error immediately.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial connection failed in activate_connection: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># If we are CONNECTING or CONNECTED_WAITING_SIDEKICK, fall through to wait.</span>

    <span class="c1"># --- Wait for READY state ---</span>
    <span class="c1"># **IMPORTANT**: Release the lock *before* waiting on the event.</span>
    <span class="c1"># This allows the listener thread (which needs the lock to update the state</span>
    <span class="c1"># and set the event) to proceed.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting up to </span><span class="si">{</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="si">}</span><span class="s2">s for Sidekick UI (_ready_event)...&quot;</span><span class="p">)</span>

    <span class="c1"># Block until the listener thread calls _ready_event.set() OR the timeout occurs.</span>
    <span class="n">ready_signal_received</span> <span class="o">=</span> <span class="n">_ready_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="p">)</span>

    <span class="c1"># --- Check Status *After* Waiting ---</span>
    <span class="c1"># Re-acquire the lock to safely check the final status.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Case 1: Success! Event was set and status is READY.</span>
        <span class="k">if</span> <span class="n">ready_signal_received</span> <span class="ow">and</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sidekick connection is now READY.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Case 2: Timeout! Event was *not* set within the time limit.</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ready_signal_received</span><span class="p">:</span>
            <span class="n">timeout_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Timed out waiting for Sidekick UI after </span><span class="si">{</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="si">}</span><span class="s2">s&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">timeout_reason</span><span class="p">)</span>
            <span class="c1"># Clean up the partially established connection since the UI never showed up.</span>
            <span class="c1"># Run cleanup in a thread to avoid potential deadlocks.</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">timeout_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">SidekickTimeoutError</span><span class="p">(</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="p">)</span>

        <span class="c1"># Case 3: Inconsistency. Event *was* set, but status is *not* READY.</span>
        <span class="c1"># This could happen if the connection dropped immediately after becoming ready,</span>
        <span class="c1"># before this thread could re-acquire the lock.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Ready event was set, but status is now inconsistent: </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connection state error: </span><span class="si">{</span><span class="n">disconnect_reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Trigger cleanup if not already disconnected.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                 <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="send_message">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.send_message">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">send_message</span><span class="p">(</span><span class="n">message_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a command message (as a dictionary) to the Sidekick UI.</span>

<span class="sd">    This is the primary way the library sends instructions like &quot;update grid cell&quot;</span>
<span class="sd">    or &quot;append text to console&quot; to the UI.</span>

<span class="sd">    How it works:</span>
<span class="sd">    1. It first calls `activate_connection()` to ensure the connection is fully</span>
<span class="sd">       ready. This might block your script initially or raise connection errors.</span>
<span class="sd">    2. If the connection is ready, it converts the `message_dict` to JSON and</span>
<span class="sd">       sends it over the WebSocket immediately.</span>

<span class="sd">    Args:</span>
<span class="sd">        message_dict (Dict[str, Any]): A Python dictionary representing the</span>
<span class="sd">            message to send. It must conform to the Sidekick communication</span>
<span class="sd">            protocol structure (including `module`, `type`, `target`/`src`,</span>
<span class="sd">            and a `payload` with **camelCase keys**). Module classes like</span>
<span class="sd">            `Grid`, `Console`, etc., construct these dictionaries internally.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the initial connection fails when</span>
<span class="sd">                                         `activate_connection` is called.</span>
<span class="sd">        SidekickTimeoutError: If waiting for the Sidekick UI times out during</span>
<span class="sd">                               `activate_connection`.</span>
<span class="sd">        SidekickDisconnectedError: If the connection is lost *before* or *during*</span>
<span class="sd">                                   the attempt to send this message.</span>
<span class="sd">        TypeError: If `message_dict` is not actually a dictionary.</span>
<span class="sd">        Exception: For other unexpected errors (e.g., JSON serialization failure).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;message_dict must be a dictionary&quot;</span><span class="p">)</span>

    <span class="c1"># 1. Ensure connection is ready. This blocks or raises if not ready.</span>
    <span class="n">activate_connection</span><span class="p">()</span>

    <span class="c1"># 2. Acquire lock to safely access the WebSocket object and send.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span>
        <span class="c1"># Double-check the status and connection object *after* getting the lock.</span>
        <span class="c1"># activate_connection() should guarantee readiness, but this is a safety</span>
        <span class="c1"># measure against rare race conditions.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ws</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ws</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Connection state invalid (</span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) just before sending&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>
            <span class="c1"># Trigger cleanup if not already disconnected.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                 <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>

        <span class="c1"># 3. Attempt the send using the internal helper.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># _send_raw handles JSON conversion and raises SidekickDisconnectedError on failure.</span>
            <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">message_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SidekickDisconnectedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># If _send_raw failed, log and initiate cleanup.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Send message failed: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
             <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                  <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Send failed: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
             <span class="c1"># Re-raise the error to notify the caller.</span>
             <span class="k">raise</span> <span class="n">e</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># Catch other unexpected errors during send (e.g., JSON issues).</span>
             <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unexpected error during send: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>
             <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                  <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
             <span class="c1"># Wrap the error.</span>
             <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="clear_all">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.clear_all">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clear_all</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a command to remove *all* visual elements from the Sidekick panel.</span>

<span class="sd">    This clears any Grids, Consoles, Viz panels, etc., that were created by</span>
<span class="sd">    *this* Python script instance. It&#39;s useful for resetting the UI state.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionError (or subclass): If the connection is not ready or</span>
<span class="sd">                                              if sending the command fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Requesting global clearAll of Sidekick UI elements.&quot;</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="c1"># Special module target for global actions</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;clearAll&quot;</span><span class="p">,</span>
        <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="kc">None</span> <span class="c1"># No extra data needed</span>
    <span class="p">}</span>
    <span class="c1"># Use the public send_message, which handles readiness checks and errors.</span>
    <span class="n">send_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="close_connection">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.close_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">close_connection</span><span class="p">(</span><span class="n">log_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Closes the WebSocket connection and cleans up resources. (Mostly internal).</span>

<span class="sd">    This function stops the listener thread, closes the WebSocket, and resets</span>
<span class="sd">    internal state. It&#39;s called automatically by `shutdown()` and `atexit`,</span>
<span class="sd">    and also internally if the listener thread detects an unrecoverable error.</span>

<span class="sd">    **You should generally use `sidekick.shutdown()` instead of calling this directly.**</span>

<span class="sd">    Args:</span>
<span class="sd">        log_info (bool): If True, logs status messages during closure.</span>
<span class="sd">        is_exception (bool): If True, indicates this closure is due to an error.</span>
<span class="sd">                             This might cause `SidekickDisconnectedError` to be</span>
<span class="sd">                             raised *after* cleanup, unless a clean shutdown via</span>
<span class="sd">                             `_shutdown_event` was already signaled.</span>
<span class="sd">        reason (str): Optional description of why the connection is closing,</span>
<span class="sd">                      used for logging and potentially in errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_connection</span><span class="p">,</span> <span class="n">_listener_thread</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_connection_status</span><span class="p">,</span> <span class="n">_message_handlers</span><span class="p">,</span> <span class="n">_sidekick_peers_online</span>

    <span class="n">disconnect_exception_to_raise</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Store potential exception</span>

    <span class="c1"># Use lock to safely modify shared state during cleanup.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Avoid closing multiple times.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection already closed or closing.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closing Sidekick WebSocket connection... (Exception: </span><span class="si">{</span><span class="n">is_exception</span><span class="si">}</span><span class="s2">, Reason: &#39;</span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>
        <span class="n">initial_status</span> <span class="o">=</span> <span class="n">_connection_status</span> <span class="c1"># Remember status before changing it</span>

        <span class="c1"># --- 1. Signal Listener to Stop ---</span>
        <span class="c1"># Tell the background thread to exit its loop.</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="c1"># Connection is no longer ready.</span>
        <span class="n">_ready_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># --- 2. Update Internal State ---</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># No longer tracking UI peers.</span>

        <span class="c1"># --- 3. Best-Effort Cleanup Messages ---</span>
        <span class="c1"># Try to send &#39;clearAll&#39; (if configured) and &#39;offline&#39; announce,</span>
        <span class="c1"># but only if this is a clean shutdown (not an error) and we</span>
        <span class="c1"># were actually connected. Don&#39;t worry too much if these fail.</span>
        <span class="n">ws_temp</span> <span class="o">=</span> <span class="n">_ws_connection</span> <span class="c1"># Grab reference under lock</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_exception</span> <span class="ow">and</span> <span class="n">ws_temp</span> <span class="ow">and</span> <span class="n">ws_temp</span><span class="o">.</span><span class="n">connected</span> <span class="ow">and</span> <span class="n">initial_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTING</span><span class="p">:</span>
             <span class="c1"># Send clearAll if configured for disconnect.</span>
             <span class="k">if</span> <span class="n">_clear_on_disconnect</span><span class="p">:</span>
                  <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempting to send global/clearAll on disconnect (best-effort).&quot;</span><span class="p">)</span>
                  <span class="n">clear_all_msg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;clearAll&quot;</span><span class="p">,</span> <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
                  <span class="k">try</span><span class="p">:</span> <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws_temp</span><span class="p">,</span> <span class="n">clear_all_msg</span><span class="p">)</span>
                  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to send clearAll during disconnect (ignored).&quot;</span><span class="p">)</span>

             <span class="c1"># Send offline announce.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempting to send offline announce (best-effort).&quot;</span><span class="p">)</span>
             <span class="k">try</span><span class="p">:</span> <span class="n">_send_system_announce</span><span class="p">(</span><span class="s2">&quot;offline&quot;</span><span class="p">)</span>
             <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to send offline announce during disconnect (ignored).&quot;</span><span class="p">)</span>

        <span class="c1"># --- 4. Close the WebSocket ---</span>
        <span class="k">if</span> <span class="n">ws_temp</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Set a short timeout for the close operation itself.</span>
                <span class="n">ws_temp</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ws_temp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during WebSocket close(): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Clear the global reference.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># --- 5. Prepare Exception (if needed) ---</span>
        <span class="c1"># If this close was triggered by an error, prepare the exception object now.</span>
        <span class="c1"># We will raise it *after* releasing the lock and joining the thread.</span>
        <span class="k">if</span> <span class="n">is_exception</span><span class="p">:</span>
            <span class="n">disconnect_exception_to_raise</span> <span class="o">=</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">reason</span> <span class="ow">or</span> <span class="s2">&quot;Connection closed due to an error&quot;</span><span class="p">)</span>

        <span class="c1"># --- 6. Clear Listener Thread References ---</span>
        <span class="n">listener_thread_temp</span> <span class="o">=</span> <span class="n">_listener_thread</span> <span class="c1"># Grab reference under lock</span>
        <span class="n">_listener_thread</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Allow listener to potentially restart later</span>

    <span class="c1"># --- 7. Join Listener Thread (Outside the main lock) ---</span>
    <span class="c1"># Wait for the listener thread to actually finish executing.</span>
    <span class="k">if</span> <span class="n">listener_thread_temp</span> <span class="ow">and</span> <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Waiting for listener thread to stop...&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Wait max ~1.5s for the listener to exit.</span>
            <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">_LISTENER_RECV_TIMEOUT</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener thread did not stop gracefully after join timeout.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">log_info</span><span class="p">:</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Listener thread stopped.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error joining listener thread: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">log_info</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Listener thread was not running or already finished.&quot;</span><span class="p">)</span>

    <span class="c1"># --- 8. Clear Instance Message Handlers ---</span>
    <span class="c1"># Can do this outside the lock after listener is stopped.</span>
    <span class="k">if</span> <span class="n">_message_handlers</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clearing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">_message_handlers</span><span class="p">)</span><span class="si">}</span><span class="s2"> instance message handlers.&quot;</span><span class="p">)</span>
        <span class="n">_message_handlers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick WebSocket connection closed.&quot;</span><span class="p">)</span>

    <span class="c1"># --- 9. Raise Exception (if needed) ---</span>
    <span class="c1"># If this cleanup was triggered by an error (`is_exception` was True),</span>
    <span class="c1"># and if a clean shutdown wasn&#39;t *also* requested concurrently via the</span>
    <span class="c1"># _shutdown_event, then raise the disconnect error now to signal the problem.</span>
    <span class="k">if</span> <span class="n">disconnect_exception_to_raise</span><span class="p">:</span>
        <span class="c1"># Check if a clean shutdown (e.g., via Ctrl+C or shutdown()) occurred</span>
        <span class="c1"># around the same time as the error.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Raising disconnect exception after cleanup: </span><span class="si">{</span><span class="n">disconnect_exception_to_raise</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Raise the exception for the calling code to handle.</span>
            <span class="k">raise</span> <span class="n">disconnect_exception_to_raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If a clean shutdown was requested, don&#39;t raise the error,</span>
            <span class="c1"># just log the original problem.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Suppressed disconnect exception because clean shutdown was also requested: </span><span class="si">{</span><span class="n">disconnect_exception_to_raise</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="run_forever">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.run_forever">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_forever</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Keeps your Python script running indefinitely to handle Sidekick UI events.</span>

<span class="sd">    Why use this? If your script needs to react to things happening in the</span>
<span class="sd">    Sidekick panel (like button clicks, grid cell clicks, or text input),</span>
<span class="sd">    your script needs to stay alive to listen for those events. Calling</span>
<span class="sd">    `run_forever()` at the end of your setup code does exactly that: it pauses</span>
<span class="sd">    the main part of your script, while allowing the background listener thread</span>
<span class="sd">    (managed by this module) to keep receiving and processing events from Sidekick,</span>
<span class="sd">    triggering your callback functions (`on_click`, `on_input_text`, etc.).</span>

<span class="sd">    How to stop it:</span>
<span class="sd">    1. Press `Ctrl+C` in the terminal where your script is running.</span>
<span class="sd">    2. Call `sidekick.shutdown()` from within one of your callback functions</span>
<span class="sd">       (e.g., have a &quot;Quit&quot; button that calls `shutdown`).</span>
<span class="sd">    3. If the connection to Sidekick breaks unexpectedly, `run_forever()` will</span>
<span class="sd">       also stop (after a `SidekickDisconnectedError` is raised).</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionError (or subclass): If the connection to Sidekick cannot</span>
<span class="sd">                                              be established *before* entering the</span>
<span class="sd">                                              waiting loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Ensure connection is ready before starting. Blocks or raises if fails.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">activate_connection</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot start run_forever: Initial connection failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Don&#39;t proceed if we can&#39;t even connect.</span>
        <span class="k">raise</span> <span class="n">e</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick entering run_forever mode. Press Ctrl+C or call sidekick.shutdown() to exit.&quot;</span><span class="p">)</span>
    <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Make sure the shutdown signal is clear initially.</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># --- Main Waiting Loop ---</span>
        <span class="c1"># Keep looping as long as the shutdown signal hasn&#39;t been set.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="c1"># Wait efficiently for the shutdown signal.</span>
            <span class="c1"># The `wait()` method will return True if the event was set,</span>
            <span class="c1"># or False if the timeout expired. Check status every second.</span>
            <span class="n">signaled</span> <span class="o">=</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">signaled</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Shutdown event signaled.&quot;</span><span class="p">)</span>
                <span class="k">break</span> <span class="c1"># Exit loop cleanly.</span>

            <span class="c1"># Optional check: If the listener detected a disconnect, exit early.</span>
            <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
                      <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run_forever: Connection status changed to </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">. Exiting loop.&quot;</span><span class="p">)</span>
                      <span class="c1"># Note: The actual SidekickDisconnectedError is likely raised by</span>
                      <span class="c1"># the listener triggering close_connection(is_exception=True).</span>
                      <span class="c1"># This check just helps exit the wait loop sooner.</span>
                      <span class="k">break</span>

    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="c1"># User pressed Ctrl+C.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;KeyboardInterrupt received, shutting down Sidekick.&quot;</span><span class="p">)</span>
        <span class="c1"># The `finally` block below will handle calling shutdown().</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch any other unexpected errors during the wait.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error during run_forever wait loop: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Let `finally` handle shutdown.</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># --- Cleanup ---</span>
        <span class="c1"># This block always runs, whether the loop exited normally,</span>
        <span class="c1"># via Ctrl+C, or an unexpected error.</span>
        <span class="c1"># Check if a clean shutdown was *already* signaled.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="c1"># If not, it means we exited for another reason (Ctrl+C, error, disconnect).</span>
            <span class="c1"># Initiate a clean shutdown now.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Loop exited unexpectedly or via Ctrl+C, initiating shutdown.&quot;</span><span class="p">)</span>
            <span class="n">shutdown</span><span class="p">()</span> <span class="c1"># Call the standard shutdown procedure.</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Loop exited cleanly via shutdown signal.&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick run_forever mode finished.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="shutdown">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.shutdown">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shutdown</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initiates a clean shutdown of the Sidekick connection.</span>

<span class="sd">    This function:</span>
<span class="sd">    - Signals `run_forever()` (if it&#39;s running) to stop waiting.</span>
<span class="sd">    - Attempts to send an &#39;offline&#39; announcement to the Sidekick server.</span>
<span class="sd">    - Attempts to send a &#39;clearAll&#39; command (if configured via `set_config`).</span>
<span class="sd">    - Closes the WebSocket connection.</span>
<span class="sd">    - Stops the background listener thread.</span>
<span class="sd">    - Clears internal state.</span>

<span class="sd">    It&#39;s safe to call this function multiple times; subsequent calls will have no effect.</span>
<span class="sd">    This function is also registered automatically via `atexit` to be called when</span>
<span class="sd">    your Python script exits normally.</span>

<span class="sd">    You might call this manually from an event handler (e.g., a &quot;Quit&quot; button&#39;s</span>
<span class="sd">    `on_click` callback) to programmatically stop `run_forever()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Check if shutdown is already done or in progress.</span>
        <span class="k">if</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shutdown already completed or in progress.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick shutdown requested.&quot;</span><span class="p">)</span>
        <span class="c1"># Signal that a clean shutdown is intended. This prevents disconnect</span>
        <span class="c1"># errors from being raised unnecessarily if cleanup happens concurrently</span>
        <span class="c1"># with an error, and tells run_forever() to stop.</span>
        <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="c1"># Initiate the closing process. Run it outside the main lock.</span>
    <span class="c1"># This is a clean shutdown request, so set is_exception=False.</span>
    <span class="n">close_connection</span><span class="p">(</span><span class="n">log_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Shutdown requested&quot;</span><span class="p">)</span></div>


<span class="c1"># --- Registration/Utility Functions (Mostly Internal/Advanced) ---</span>

<div class="viewcode-block" id="register_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.register_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_message_handler</span><span class="p">(</span><span class="n">instance_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Registers a function to handle messages for a specific module instance. (Internal use).</span>

<span class="sd">    This is automatically called by the base class (`BaseModule`) when you</span>
<span class="sd">    create a Sidekick module instance (like `Grid`, `Console`). The provided</span>
<span class="sd">    `handler` function (usually the `_internal_message_handler` method of the</span>
<span class="sd">    instance) will be called by the listener thread whenever an &#39;event&#39; or</span>
<span class="sd">    &#39;error&#39; message arrives from the Sidekick UI with a `src` field matching</span>
<span class="sd">    the `instance_id`.</span>

<span class="sd">    Args:</span>
<span class="sd">        instance_id (str): The unique ID of the module instance (e.g., &quot;grid-1&quot;).</span>
<span class="sd">        handler (Callable): The function to call for incoming messages for this ID.</span>
<span class="sd">                            It must accept one argument: the message dictionary.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the provided handler is not a callable function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; must be callable.&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only register if the connection isn&#39;t already fully shut down.</span>
        <span class="c1"># Allows registration even before connection is fully READY.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering internal message handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="n">_message_handlers</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connection closed or closing, handler for &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; not registered.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="unregister_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.unregister_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unregister_message_handler</span><span class="p">(</span><span class="n">instance_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes the message handler for a specific module instance. (Internal use).</span>

<span class="sd">    This is called automatically when a module&#39;s `remove()` method is used,</span>
<span class="sd">    or during the final `close_connection` cleanup.</span>

<span class="sd">    Args:</span>
<span class="sd">        instance_id (str): The ID of the module instance whose handler should be removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Remove the handler from the dictionary if it exists.</span>
        <span class="k">if</span> <span class="n">instance_id</span> <span class="ow">in</span> <span class="n">_message_handlers</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unregistering internal message handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_message_handlers</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># It&#39;s normal for this to happen during cleanup if already removed.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No internal message handler found for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; to unregister.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="register_global_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.register_global_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_global_message_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Registers a single function to receive *all* incoming messages from Sidekick.</span>

<span class="sd">    **Advanced Usage:** This is mostly intended for debugging or building very</span>
<span class="sd">    custom low-level integrations. The function you provide here will be called</span>
<span class="sd">    by the listener thread for *every* message received from the Sidekick server,</span>
<span class="sd">    *before* the message is dispatched to any specific module instance handlers.</span>

<span class="sd">    Args:</span>
<span class="sd">        handler (Optional[Callable]): The function to call with each raw message</span>
<span class="sd">            dictionary received. It should accept one argument (the message dict).</span>
<span class="sd">            Pass `None` to remove any existing global handler.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the provided handler is not callable and not `None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_global_message_handler</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove the global handler.</span>
            <span class="k">if</span> <span class="n">_global_message_handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unregistering global message handler.&quot;</span><span class="p">)</span>
                <span class="n">_global_message_handler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="c1"># Set the new global handler.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering global message handler: </span><span class="si">{</span><span class="n">handler</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">_global_message_handler</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Global message handler must be callable or None.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_next_command_id">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.get_next_command_id">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_next_command_id</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates the next sequential ID for Canvas drawing commands. (Internal use).</span>

<span class="sd">    The Sidekick Canvas protocol requires each drawing command (`line`, `rect`, etc.)</span>
<span class="sd">    to have a unique, sequential ID within the connection session. This function</span>
<span class="sd">    provides those IDs.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The next unique command ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_command_counter</span>
    <span class="c1"># Use lock for thread safety, although typically only called from main thread.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">_command_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">_command_counter</span></div>


<span class="c1"># --- Automatic Cleanup on Exit ---</span>
<span class="c1"># Register the main shutdown() function to be called automatically when the</span>
<span class="c1"># Python interpreter exits normally. This ensures we attempt to close the</span>
<span class="c1"># WebSocket, stop the listener, and send cleanup messages if possible.</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">shutdown</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Enjan Chou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>