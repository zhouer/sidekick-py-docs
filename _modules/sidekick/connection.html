

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sidekick.connection &mdash; Sidekick Python Library 0.0.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=282f96c0"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Sidekick Python Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">sidekick</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/zhouer/Sidekick">GitHub Repository</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/sidekick-py/">PyPI Package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Sidekick Python Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sidekick.connection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sidekick.connection</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Manages the WebSocket connection between your Python script and the Sidekick UI.</span>

<span class="sd">This module acts as the central communication hub for the Sidekick library. It</span>
<span class="sd">handles the technical details of establishing and maintaining a real-time</span>
<span class="sd">connection with the Sidekick panel running in Visual Studio Code.</span>

<span class="sd">Key Responsibilities:</span>

<span class="sd">*   **Connecting:** Automatically attempts to connect to the Sidekick server</span>
<span class="sd">    (usually running within the VS Code extension) the first time your script</span>
<span class="sd">    tries to interact with a Sidekick module (e.g., when you create `sidekick.Grid()`).</span>
<span class="sd">*   **Blocking Connection:** It **pauses** (blocks) your script during the initial</span>
<span class="sd">    connection phase until it confirms that both the server is reached and the</span>
<span class="sd">    Sidekick UI panel is loaded and ready to receive commands. This ensures your</span>
<span class="sd">    commands don&#39;t get lost.</span>
<span class="sd">*   **Sending Commands:** Provides the mechanism (`send_message`, used internally</span>
<span class="sd">    by modules like Grid, Console) to send instructions (like &quot;set color&quot;, &quot;print text&quot;)</span>
<span class="sd">    to the Sidekick UI.</span>
<span class="sd">*   **Receiving Events:** Runs a background thread (`_listen_for_messages`) to listen</span>
<span class="sd">    for messages coming *from* the Sidekick UI (like button clicks or text input)</span>
<span class="sd">    and routes them to the correct handler function in your script (e.g., the</span>
<span class="sd">    function you provided to `grid.on_click`).</span>
<span class="sd">*   **Error Handling:** Raises specific `SidekickConnectionError` exceptions if it</span>
<span class="sd">    cannot connect, if the UI doesn&#39;t respond, or if the connection is lost later.</span>
<span class="sd">*   **Lifecycle Management:** Handles clean shutdown procedures, ensuring resources</span>
<span class="sd">    are released when your script finishes or when `sidekick.shutdown()` is called.</span>

<span class="sd">Note:</span>
<span class="sd">    You typically interact with this module indirectly through functions like</span>
<span class="sd">    `sidekick.run_forever()` or `sidekick.shutdown()`, or simply by using the</span>
<span class="sd">    visual module classes (`Grid`, `Console`, etc.). However, understanding its</span>
<span class="sd">    role helps explain the library&#39;s behavior, especially regarding connection</span>
<span class="sd">    and event handling. The library does **not** automatically attempt to reconnect</span>
<span class="sd">    if the connection is lost after being established.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">websocket</span> <span class="c1"># The library used for WebSocket communication (websocket-client)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">atexit</span> <span class="c1"># Used to automatically call shutdown() when the script exits normally</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Set</span>

<span class="c1"># --- Import logger and Version ---</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._version</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span>

<span class="c1"># --- Custom Exceptions ---</span>
<span class="c1"># Define specific error types for connection problems, making it easier</span>
<span class="c1"># for users to catch and potentially handle different failure scenarios.</span>

<div class="viewcode-block" id="SidekickConnectionError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickConnectionError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickConnectionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base error for all Sidekick connection-related problems.</span>

<span class="sd">    Catch this exception type if you want to handle any issue related to</span>
<span class="sd">    establishing or maintaining the connection to the Sidekick panel.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     console = sidekick.Console() # Connection happens here</span>
<span class="sd">        ...     console.print(&quot;Connected!&quot;)</span>
<span class="sd">        ... except sidekick.SidekickConnectionError as e:</span>
<span class="sd">        ...     print(f&quot;Could not connect to Sidekick: {e}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SidekickConnectionRefusedError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickConnectionRefusedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the library fails to connect to the Sidekick server initially.</span>

<span class="sd">    This usually means the Sidekick WebSocket server wasn&#39;t running or couldn&#39;t</span>
<span class="sd">    be reached at the configured URL (`ws://localhost:5163` by default).</span>

<span class="sd">    Common Causes:</span>

<span class="sd">    1. The Sidekick panel isn&#39;t open and active in VS Code.</span>
<span class="sd">    2. The Sidekick VS Code extension isn&#39;t running correctly or has encountered an error.</span>
<span class="sd">    3. The WebSocket server couldn&#39;t start (e.g., the port is already in use by another</span>
<span class="sd">       application). Check VS Code&#39;s &quot;Sidekick Server&quot; output channel for details.</span>
<span class="sd">    4. A firewall is blocking the connection between your script and VS Code.</span>
<span class="sd">    5. The URL was changed via `sidekick.set_url()` to an incorrect address.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        url (str): The WebSocket URL that the connection attempt was made to.</span>
<span class="sd">        original_exception (Exception): The lower-level error that caused the failure</span>
<span class="sd">            (e.g., `ConnectionRefusedError` from the OS, `TimeoutError` from the</span>
<span class="sd">            `websocket` library).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_exception</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_exception</span> <span class="o">=</span> <span class="n">original_exception</span>
        <span class="c1"># User-friendly error message suggesting common fixes.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Failed to connect to Sidekick server at </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Reason: </span><span class="si">{</span><span class="n">original_exception</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Is the Sidekick panel open in VS Code? &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Check the URL, potential port conflicts (default 5163), and firewall settings.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SidekickTimeoutError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickTimeoutError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickTimeoutError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when connection to the server succeeds, but the Sidekick UI panel doesn&#39;t respond.</span>

<span class="sd">    After successfully connecting to the WebSocket server (run by the VS Code extension),</span>
<span class="sd">    the library waits a short time (a few seconds) for the Sidekick UI panel itself</span>
<span class="sd">    (the web content inside the panel) to finish loading and send back a signal</span>
<span class="sd">    confirming it&#39;s ready to receive commands. If this signal doesn&#39;t arrive</span>
<span class="sd">    within the timeout period, this error is raised.</span>

<span class="sd">    Common Causes:</span>

<span class="sd">    1. The Sidekick panel is open in VS Code, but it hasn&#39;t finished loading its</span>
<span class="sd">       HTML/JavaScript content yet (e.g., due to slow system performance or</span>
<span class="sd">       network issues if loading remote resources, though usually local).</span>
<span class="sd">    2. There&#39;s an error within the Sidekick UI panel&#39;s JavaScript code preventing</span>
<span class="sd">       it from initializing correctly. Check the Webview Developer Tools in VS Code</span>
<span class="sd">       (Command Palette -&gt; &quot;Developer: Open Webview Developer Tools&quot;) for errors.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        timeout (float): The number of seconds the library waited for the UI response.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="c1"># User-friendly message explaining the timeout.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Connected to the Sidekick server, but timed out after </span><span class="si">{</span><span class="n">timeout</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> seconds &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;waiting for the Sidekick UI panel itself to signal it&#39;s ready. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Is the panel visible and fully loaded in VS Code? Check Webview Developer Tools for errors.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SidekickDisconnectedError">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.SidekickDisconnectedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SidekickDisconnectedError</span><span class="p">(</span><span class="n">SidekickConnectionError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the connection is lost *after* it was successfully established.</span>

<span class="sd">    This indicates that communication was working previously, but the connection</span>
<span class="sd">    broke unexpectedly. This can happen if you try to send a command or if the</span>
<span class="sd">    background listener thread detects the disconnection.</span>

<span class="sd">    Common Causes:</span>

<span class="sd">    1. The Sidekick panel was closed in VS Code while your script was still running.</span>
<span class="sd">    2. The Sidekick VS Code extension crashed, was disabled, or VS Code was closed.</span>
<span class="sd">    3. A network interruption occurred between the Python script and VS Code (less</span>
<span class="sd">       common for local connections but possible).</span>
<span class="sd">    4. An internal error occurred while trying to send or receive a message over</span>
<span class="sd">       the established connection.</span>

<span class="sd">    **Important:** The library will **not** automatically try to reconnect if this</span>
<span class="sd">    error occurs. Any further attempts to use Sidekick modules (like `grid.set_color()`)</span>
<span class="sd">    will also fail until the script is potentially restarted and a new connection</span>
<span class="sd">    is established.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        reason (str): A short description of why the disconnection occurred or was detected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Connection lost&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reason</span> <span class="o">=</span> <span class="n">reason</span>
        <span class="c1"># User-friendly message explaining the disconnection.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sidekick connection lost: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The connection was active but is now broken. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The library will not automatically reconnect.&quot;</span>
        <span class="p">)</span></div>


<span class="c1"># --- Connection Status Enum ---</span>
<div class="viewcode-block" id="ConnectionStatus">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.ConnectionStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConnectionStatus</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents the different states of the WebSocket connection internally.&quot;&quot;&quot;</span>
    <span class="n">DISCONNECTED</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>               <span class="c1"># Not connected. Initial state, or after closing/error.</span>
    <span class="n">CONNECTING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>                 <span class="c1"># Actively trying to establish the WebSocket link.</span>
    <span class="n">CONNECTED_WAITING_SIDEKICK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span> <span class="c1"># WebSocket link established, waiting for UI panel &#39;ready&#39; signal.</span>
    <span class="n">CONNECTED_READY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># Fully connected and confirmed UI panel is ready. Safe to send messages.</span></div>


<span class="c1"># --- Configuration and State (Internal Variables) ---</span>
<span class="c1"># These variables manage the connection details and current state.</span>
<span class="c1"># They are considered internal implementation details.</span>

<span class="c1"># Default WebSocket URL. Can be changed via sidekick.set_url().</span>
<span class="n">_ws_url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ws://localhost:5163&quot;</span>
<span class="c1"># Holds the active websocket.WebSocket object once connected.</span>
<span class="n">_ws_connection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocket</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># A reentrant lock to protect access to shared state variables (status, connection object, handlers, etc.)</span>
<span class="c1"># from race conditions between the main thread and the listener thread. RLock allows the same thread</span>
<span class="c1"># to acquire the lock multiple times.</span>
<span class="n">_connection_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
<span class="c1"># The background thread object responsible for listening for incoming messages.</span>
<span class="n">_listener_thread</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># Internal flag to track if the listener thread has been started for the current connection cycle.</span>
<span class="n">_listener_started</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># Maps module instance IDs (e.g., &quot;grid-1&quot;) to their specific message handler function</span>
<span class="c1"># (usually the _internal_message_handler method of the module instance).</span>
<span class="n">_message_handlers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># A unique ID generated for this specific Python script (&quot;Hero&quot;) instance run.</span>
<span class="n">_peer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># Tracks the current status using the ConnectionStatus enum. Crucial for state management.</span>
<span class="n">_connection_status</span><span class="p">:</span> <span class="n">ConnectionStatus</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
<span class="c1"># Stores the peer IDs of Sidekick UI instances that have announced they are online via system/announce.</span>
<span class="n">_sidekick_peers_online</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="c1"># Configuration flags set via sidekick.set_config.</span>
<span class="n">_clear_on_connect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>   <span class="c1"># Should the UI be cleared when connection becomes ready?</span>
<span class="n">_clear_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Should we *try* to clear the UI on clean shutdown?</span>
<span class="c1"># An optional global handler (for debugging/advanced use) that receives *all* messages.</span>
<span class="n">_global_message_handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># --- Threading Events for Synchronization ---</span>
<span class="c1"># These events are used to coordinate actions between the main script thread,</span>
<span class="c1"># the background listener thread, and shutdown procedures.</span>
<span class="n">_stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>      <span class="c1"># Signals the listener thread that it should stop running cleanly.</span>
<span class="n">_ready_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>     <span class="c1"># Set by the listener when the full connection (including UI ready) is established.</span>
                                     <span class="c1"># activate_connection() waits on this.</span>
<span class="n">_shutdown_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>  <span class="c1"># Set by shutdown() or Ctrl+C to signal run_forever() to exit its wait loop.</span>

<span class="c1"># --- Constants ---</span>
<span class="c1"># Timeouts and intervals used for connection and communication reliability.</span>
<span class="n">_INITIAL_CONNECT_TIMEOUT</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="c1"># Max seconds to wait for websocket.create_connection() to succeed.</span>
<span class="n">_SIDEKICK_WAIT_TIMEOUT</span> <span class="o">=</span> <span class="mf">2.0</span>   <span class="c1"># Max seconds activate_connection() waits for the _ready_event after server connect.</span>
<span class="n">_LISTENER_RECV_TIMEOUT</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c1"># How long ws.recv() waits in the listener loop before timing out.</span>
                               <span class="c1"># Allows the loop to check _stop_event periodically without blocking indefinitely.</span>
<span class="c1"># WebSocket Ping settings (using websocket-client&#39;s built-in ping):</span>
<span class="n">_PING_INTERVAL</span> <span class="o">=</span> <span class="mi">20</span>            <span class="c1"># Send a WebSocket PING frame every 20 seconds if no other messages are sent.</span>
<span class="n">_PING_TIMEOUT</span> <span class="o">=</span> <span class="mi">10</span>             <span class="c1"># Wait a maximum of 10 seconds for a PONG reply after sending a PING.</span>
                               <span class="c1"># Helps detect unresponsive/dead connections sooner than TCP timeouts.</span>

<span class="c1"># --- Private Helper Functions (Internal Use Only) ---</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_generate_peer_id</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates or returns the unique ID for this Python script instance (&#39;Hero&#39;). Internal use.&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_peer_id</span>
    <span class="c1"># Generate only once per script execution.</span>
    <span class="k">if</span> <span class="n">_peer_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create a unique ID using UUIDv4 for randomness.</span>
        <span class="n">_peer_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hero-</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generated Hero Peer ID: </span><span class="si">{</span><span class="n">_peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_peer_id</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">:</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocket</span><span class="p">,</span> <span class="n">message_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Safely serializes a dictionary to JSON and sends it over the WebSocket. Internal use.</span>

<span class="sd">    Handles JSON encoding and raises SidekickDisconnectedError if the send fails.</span>

<span class="sd">    Args:</span>
<span class="sd">        ws: The active WebSocket connection object.</span>
<span class="sd">        message_dict: The Python dictionary payload to send.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickDisconnectedError: If sending fails due to WebSocket-level issues</span>
<span class="sd">            (e.g., connection closed, broken pipe, OS errors during send).</span>
<span class="sd">        Exception: For other unexpected errors like JSON serialization problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Convert the dictionary to a JSON string (UTF-8 encoded by default).</span>
        <span class="n">message_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message_dict</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sending raw: </span><span class="si">{</span><span class="n">message_json</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Send the JSON string via the WebSocket connection.</span>
        <span class="n">ws</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">message_json</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketException</span><span class="p">,</span> <span class="ne">BrokenPipeError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># These errors typically indicate the connection is no longer viable.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WebSocket send error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Connection likely lost.&quot;</span><span class="p">)</span>
        <span class="c1"># Raise our specific error to signal disconnection to the caller (send_message).</span>
        <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Send failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch other potential errors (e.g., json.dumps failure if data is not serializable).</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error sending message: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Treat unexpected send errors as a disconnection as well.</span>
        <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected send error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_send_system_announce</span><span class="p">(</span><span class="n">status</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a &#39;system/announce&#39; message to the server. Internal use.</span>

<span class="sd">    Used to inform the server and other peers (like the UI) about this script&#39;s</span>
<span class="sd">    online/offline status, role (&#39;hero&#39;), and version, following the protocol spec.</span>

<span class="sd">    Args:</span>
<span class="sd">        status (str): Either &quot;online&quot; or &quot;offline&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Acquire lock for safe access to shared connection object.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span> <span class="c1"># Get the current WebSocket object reference.</span>
        <span class="n">peer_id</span> <span class="o">=</span> <span class="n">_generate_peer_id</span><span class="p">()</span> <span class="c1"># Ensure we have our unique ID.</span>

        <span class="c1"># Only proceed if we have a seemingly valid, connected WebSocket.</span>
        <span class="k">if</span> <span class="n">ws</span> <span class="ow">and</span> <span class="n">ws</span><span class="o">.</span><span class="n">connected</span> <span class="ow">and</span> <span class="n">peer_id</span><span class="p">:</span>
            <span class="c1"># Construct the payload according to the protocol specification.</span>
            <span class="n">announce_payload</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;peerId&quot;</span><span class="p">:</span> <span class="n">peer_id</span><span class="p">,</span>          <span class="c1"># Our unique identifier.</span>
                <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;hero&quot;</span><span class="p">,</span>             <span class="c1"># Identify as the Python script.</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>           <span class="c1"># &#39;online&#39; or &#39;offline&#39;.</span>
                <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">__version__</span><span class="p">,</span>     <span class="c1"># Report the library version.</span>
                <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1"># Current Unix time in milliseconds.</span>
            <span class="p">}</span>
            <span class="c1"># Construct the full message structure.</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># Reserved, usually 0.</span>
                <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;system&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;announce&quot;</span><span class="p">,</span>
                <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">announce_payload</span>
            <span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Use the safe sending helper.</span>
                <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sent system announce: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SidekickDisconnectedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># It&#39;s possible sending announce fails (e.g., during shutdown if connection</span>
                <span class="c1"># drops simultaneously). Log a warning but don&#39;t crash the process.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not send system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39; (connection likely closing): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error sending system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;offline&quot;</span><span class="p">:</span>
             <span class="c1"># If we&#39;re trying to send &#39;offline&#39; but are already disconnected, that&#39;s expected.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cannot send offline announce, connection already closed or closing.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="c1"># If trying to send &#39;online&#39; but not connected, that&#39;s an issue.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot send system announce &#39;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&#39;, WebSocket is not connected.&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_listen_for_messages</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The main function executed by the background listener thread. Internal use.</span>

<span class="sd">    Continuously waits for incoming messages from the WebSocket server, parses</span>
<span class="sd">    the JSON, and dispatches them to the appropriate handlers (_global_message_handler</span>
<span class="sd">    or specific module instance handlers registered in _message_handlers).</span>

<span class="sd">    It also specifically handles `system/announce` messages from the Sidekick UI</span>
<span class="sd">    to track its readiness and update the `_connection_status` and `_ready_event`.</span>

<span class="sd">    This function runs until `_stop_event` is set or an unrecoverable connection</span>
<span class="sd">    error occurs. If an unexpected error happens, it initiates the `close_connection`</span>
<span class="sd">    process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_connection_status</span><span class="p">,</span> <span class="n">_message_handlers</span><span class="p">,</span> <span class="n">_sidekick_peers_online</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_global_message_handler</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener thread started.&quot;</span><span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Holds the reference to the WebSocket connection for this loop iteration.</span>
    <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Listener thread terminated normally&quot;</span> <span class="c1"># Default exit reason.</span>

    <span class="c1"># Loop indefinitely until the stop signal is received.</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="c1"># --- Check Connection State Safely (Under Lock) ---</span>
        <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
            <span class="c1"># If the connection status was changed externally (e.g., by shutdown()), exit the loop.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Status became DISCONNECTED&quot;</span>
                <span class="k">break</span>
            <span class="c1"># Ensure we still have a valid WebSocket object and it thinks it&#39;s connected.</span>
            <span class="k">if</span> <span class="n">_ws_connection</span> <span class="ow">and</span> <span class="n">_ws_connection</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span> <span class="c1"># Use the current connection object.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the connection object is gone or disconnected, exit the loop.</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocket connection lost or object is None&quot;</span>
                <span class="c1"># Only log a warning if this wasn&#39;t a planned stop.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket connection lost or unavailable.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="c1"># Check ws again outside the lock (mostly redundant, but safe).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ws</span><span class="p">:</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocket object is None (checked outside lock)&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket object is None, stopping loop.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># --- Receive Message ---</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Wait for an incoming message, with a timeout.</span>
            <span class="c1"># The timeout (_LISTENER_RECV_TIMEOUT) is crucial: it prevents recv()</span>
            <span class="c1"># from blocking forever, allowing the loop to periodically check _stop_event.</span>
            <span class="n">ws</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="n">_LISTENER_RECV_TIMEOUT</span><span class="p">)</span>
            <span class="n">message_str</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

            <span class="c1"># Check if stop was signaled *while* we were blocked waiting for recv().</span>
            <span class="k">if</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Stop event set during receive wait&quot;</span>
                <span class="k">break</span>

            <span class="c1"># An empty message usually signifies the server closed the connection gracefully.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">message_str</span><span class="p">:</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;Server closed connection (received empty message)&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener: Server closed the WebSocket connection.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received raw message: </span><span class="si">{</span><span class="n">message_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Parse the incoming JSON string into a Python dictionary.</span>
            <span class="n">message_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message_str</span><span class="p">)</span>

            <span class="c1"># --- Process Message Safely (Under Lock) ---</span>
            <span class="c1"># Re-acquire the lock to safely access/modify shared state (status, handlers)</span>
            <span class="c1"># while processing the received message.</span>
            <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
                <span class="c1"># Final check: if status changed or stop signaled while parsing, exit.</span>
                <span class="k">if</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># --- 1. Call Global Handler (if registered) ---</span>
                <span class="c1"># Used for debugging/advanced scenarios.</span>
                <span class="k">if</span> <span class="n">_global_message_handler</span><span class="p">:</span>
                     <span class="k">try</span><span class="p">:</span>
                         <span class="c1"># Pass the raw parsed message dictionary.</span>
                         <span class="n">_global_message_handler</span><span class="p">(</span><span class="n">message_data</span><span class="p">)</span>
                     <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                         <span class="c1"># Log errors in the global handler but don&#39;t crash the listener.</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Error in global message handler: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># --- 2. Message Dispatch Logic ---</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">)</span>
                <span class="n">msg_type</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>
                <span class="n">payload</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;payload&#39;</span><span class="p">)</span> <span class="c1"># Note: Payload keys should be camelCase per protocol.</span>

                <span class="c1"># --- Handle System Announce (Sidekick UI Ready?) ---</span>
                <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s1">&#39;system&#39;</span> <span class="ow">and</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s1">&#39;announce&#39;</span> <span class="ow">and</span> <span class="n">payload</span><span class="p">:</span>
                    <span class="n">peer_id</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;peerId&#39;</span><span class="p">)</span>
                    <span class="n">role</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;role&#39;</span><span class="p">)</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">)</span>

                    <span class="c1"># Only process announcements from &#39;sidekick&#39; peers (the UI).</span>
                    <span class="k">if</span> <span class="n">peer_id</span> <span class="ow">and</span> <span class="n">role</span> <span class="o">==</span> <span class="s1">&#39;sidekick&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;online&#39;</span><span class="p">:</span>
                            <span class="c1"># A Sidekick UI panel just connected or announced readiness.</span>
                            <span class="c1"># Check if this is the *first* Sidekick UI we&#39;ve seen.</span>
                            <span class="n">was_empty</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">_sidekick_peers_online</span>
                            <span class="c1"># Add it to our set of known online UIs.</span>
                            <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">peer_id</span><span class="p">)</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick peer online: </span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                            <span class="c1"># CRITICAL: If this is the first UI and we were waiting...</span>
                            <span class="k">if</span> <span class="n">was_empty</span> <span class="ow">and</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_WAITING_SIDEKICK</span><span class="p">:</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First Sidekick UI &#39;</span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&#39; announced online. Connection is now READY.&quot;</span><span class="p">)</span>
                                <span class="c1"># Transition the state to fully ready.</span>
                                <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span>
                                <span class="c1"># If configured, send a &#39;clearAll&#39; command now that the UI is ready.</span>
                                <span class="k">if</span> <span class="n">_clear_on_connect</span><span class="p">:</span>
                                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;clear_on_connect is True, sending global/clearAll.&quot;</span><span class="p">)</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="c1"># Can call clear_all directly now, connection assumed ready.</span>
                                        <span class="n">clear_all</span><span class="p">()</span>
                                    <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e_clr</span><span class="p">:</span>
                                        <span class="c1"># Log if the clear fails, but don&#39;t stop the listener.</span>
                                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to send clearAll on connect: </span><span class="si">{</span><span class="n">e_clr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="c1"># IMPORTANT: Signal the main thread (waiting in activate_connection)</span>
                                <span class="c1"># by setting the _ready_event. This unblocks the script.</span>
                                <span class="n">_ready_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

                        <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;offline&#39;</span><span class="p">:</span>
                            <span class="c1"># A Sidekick UI panel disconnected or went offline.</span>
                            <span class="k">if</span> <span class="n">peer_id</span> <span class="ow">in</span> <span class="n">_sidekick_peers_online</span><span class="p">:</span>
                                <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">peer_id</span><span class="p">)</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick peer offline: </span><span class="si">{</span><span class="n">peer_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="c1"># Note: The connection status remains CONNECTED_READY even if all UIs leave.</span>
                                <span class="c1"># A disconnect error will only occur if the underlying WebSocket connection</span>
                                <span class="c1"># breaks or if a subsequent send/receive operation fails.</span>

                <span class="c1"># --- Handle Module Event/Error (Dispatch to Specific Instance) ---</span>
                <span class="k">elif</span> <span class="n">msg_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">]:</span>
                    <span class="c1"># These messages originate *from* a specific module instance in the UI.</span>
                    <span class="c1"># The &#39;src&#39; field in the message identifies which instance.</span>
                    <span class="n">instance_id</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">)</span>
                    <span class="c1"># Check if we have a handler registered for this specific instance ID.</span>
                    <span class="k">if</span> <span class="n">instance_id</span> <span class="ow">and</span> <span class="n">instance_id</span> <span class="ow">in</span> <span class="n">_message_handlers</span><span class="p">:</span>
                        <span class="n">handler</span> <span class="o">=</span> <span class="n">_message_handlers</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Invoking handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; (type: </span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
                             <span class="c1"># Call the instance&#39;s registered handler (e.g., Grid._internal_message_handler).</span>
                             <span class="n">handler</span><span class="p">(</span><span class="n">message_data</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                             <span class="c1"># Catch errors within the user&#39;s callback or the internal handler logic.</span>
                             <span class="c1"># Log the error but continue the listener loop.</span>
                             <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Error executing handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">instance_id</span><span class="p">:</span>
                        <span class="c1"># Received a message for an instance we don&#39;t know (e.g., removed).</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: No handler registered for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; for message type &#39;</span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">&#39;. Ignoring.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Malformed message missing the &#39;src&#39; identifier.</span>
                         <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received &#39;</span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">&#39; message without required &#39;src&#39; field: </span><span class="si">{</span><span class="n">message_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Received a message type the listener doesn&#39;t handle directly (e.g., &#39;spawn&#39; from UI).</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Received unhandled message type: module=&#39;</span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s2">&#39;, type=&#39;</span><span class="si">{</span><span class="n">msg_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketTimeoutException</span><span class="p">:</span>
            <span class="c1"># This is expected due to ws.settimeout(). It&#39;s not an error.</span>
            <span class="c1"># Simply continue the loop to check _stop_event and wait again.</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketConnectionClosedException</span><span class="p">:</span>
            <span class="c1"># The server actively closed the connection while we were listening.</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="s2">&quot;WebSocketConnectionClosedException&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span> <span class="c1"># Log only if it wasn&#39;t expected.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Listener: WebSocket connection closed by server.&quot;</span><span class="p">)</span>
            <span class="k">break</span> <span class="c1"># Exit the loop.</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Received data that wasn&#39;t valid JSON or had unexpected types.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Failed to parse incoming JSON or invalid data type: </span><span class="si">{</span><span class="n">message_str</span><span class="si">}</span><span class="s2">. Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span> <span class="c1"># Try to recover and continue listening.</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Catch lower-level OS errors (e.g., network issues, bad file descriptor).</span>
            <span class="c1"># Ignore &quot;Bad file descriptor&quot; (errno 9) if we are stopping, as it&#39;s expected.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="mi">9</span><span class="p">):</span>
                <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;OS error (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                     <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: OS error occurred (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">), likely connection lost.&quot;</span><span class="p">)</span>
                <span class="k">break</span> <span class="c1"># Exit the loop on significant OS errors.</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Catch any other unexpected error during the loop.</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unexpected error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span> <span class="c1"># Log only if unexpected.</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener: Unexpected error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span> <span class="c1"># Exit the loop.</span>

    <span class="c1"># --- Listener Loop Exit ---</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener thread finished. Reason: </span><span class="si">{</span><span class="n">disconnect_reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure the flag reflects that the listener is no longer running.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Allow listener to potentially restart on next connection attempt.</span>

    <span class="c1"># If the loop exited *unexpectedly* (i.e., not because _stop_event was set)...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Listener thread terminated unexpectedly. Initiating disconnect cleanup.&quot;</span><span class="p">)</span>
        <span class="c1"># Trigger the full cleanup process. This will likely lead to a</span>
        <span class="c1"># SidekickDisconnectedError being raised for the main thread eventually.</span>
        <span class="c1"># Crucially, run close_connection in a *separate non-daemon thread*</span>
        <span class="c1"># This avoids potential deadlocks if close_connection needs to acquire locks held</span>
        <span class="c1"># elsewhere, and ensures cleanup completes even if the main script exits.</span>
        <span class="c1"># Marking as an exception scenario.</span>
        <span class="n">cleanup_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="c1"># log_info=False, is_exception=True</span>
            <span class="n">daemon</span><span class="o">=</span><span class="kc">False</span> <span class="c1"># Make sure cleanup finishes</span>
        <span class="p">)</span>
        <span class="n">cleanup_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_connection</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Establishes the initial WebSocket connection and starts the listener. Internal use.</span>

<span class="sd">    Called only by `activate_connection` when the status is `DISCONNECTED`.</span>
<span class="sd">    It handles the `websocket.create_connection` call and starts the `_listen_for_messages`</span>
<span class="sd">    thread if the connection is successful.</span>

<span class="sd">    Note:</span>
<span class="sd">        This function assumes the caller (`activate_connection`) holds the `_connection_lock`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the initial WebSocket `create_connection` fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_connection</span><span class="p">,</span> <span class="n">_listener_thread</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_connection_status</span>

    <span class="c1"># Safety check: Should only be called when DISCONNECTED.</span>
    <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
        <span class="c1"># This indicates a potential logic error elsewhere.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_ensure_connection called unexpectedly while status is </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempting to connect to Sidekick server at </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
    <span class="c1"># --- Prepare for New Connection Attempt ---</span>
    <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTING</span> <span class="c1"># Update state</span>
    <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Reset known UI peers for this new connection.</span>
    <span class="c1"># Reset threading events to their initial (cleared) state.</span>
    <span class="n">_stop_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">_ready_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c1"># --- Attempt WebSocket Connection ---</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># This is the blocking call that tries to establish the WebSocket connection.</span>
        <span class="c1"># It uses the configured URL and initial connection timeout.</span>
        <span class="c1"># It also configures automatic background ping/pong handling.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="n">websocket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
            <span class="n">_ws_url</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">_INITIAL_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">ping_interval</span><span class="o">=</span><span class="n">_PING_INTERVAL</span><span class="p">,</span> <span class="c1"># Send pings if connection idle</span>
            <span class="n">ping_timeout</span><span class="o">=</span><span class="n">_PING_TIMEOUT</span>    <span class="c1"># Timeout if pong not received</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Successfully connected to Sidekick server (WebSocket established).&quot;</span><span class="p">)</span>

        <span class="c1"># --- Connection Succeeded ---</span>
        <span class="c1"># Immediately send our &#39;online&#39; announcement to identify ourselves.</span>
        <span class="n">_send_system_announce</span><span class="p">(</span><span class="s2">&quot;online&quot;</span><span class="p">)</span>
        <span class="c1"># Update status: WebSocket connected, but waiting for UI panel confirmation.</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_WAITING_SIDEKICK</span>

        <span class="c1"># Start the listener thread if it&#39;s not already running (e.g., from a previous failed attempt).</span>
        <span class="c1"># Check both the flag and the thread&#39;s alive status for robustness.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_listener_started</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_listener_thread</span> <span class="ow">and</span> <span class="n">_listener_thread</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting WebSocket listener thread.&quot;</span><span class="p">)</span>
            <span class="c1"># Create the thread. Set daemon=True so it doesn&#39;t prevent script exit</span>
            <span class="c1"># if the main thread finishes without calling shutdown().</span>
            <span class="n">_listener_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">_listen_for_messages</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">_listener_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Mark that the listener is running for this cycle.</span>
        <span class="k">elif</span> <span class="n">_listener_started</span><span class="p">:</span>
             <span class="c1"># This state should ideally not be reached if status management is correct.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;_ensure_connection: Listener thread already marked as started (unexpected).&quot;</span><span class="p">)</span>

    <span class="c1"># --- Handle Connection Errors ---</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">websocket</span><span class="o">.</span><span class="n">WebSocketException</span><span class="p">,</span> <span class="ne">ConnectionRefusedError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">TimeoutError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch specific errors indicating failure to connect.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to connect to Sidekick server at </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Clean up state: Mark as disconnected, clear connection object.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="c1"># Signal the listener thread (if it somehow started before failing) to stop.</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Raise the specific error for activate_connection to catch and report to the user.</span>
        <span class="k">raise</span> <span class="n">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">_ws_url</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch any other unexpected errors during the connection process.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error during Sidekick connection setup: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Perform similar cleanup.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Wrap the unexpected error in our specific connection error type.</span>
        <span class="k">raise</span> <span class="n">SidekickConnectionRefusedError</span><span class="p">(</span><span class="n">_ws_url</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>


<span class="c1"># --- Public API Functions ---</span>

<div class="viewcode-block" id="set_url">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.set_url">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sets the WebSocket URL where the Sidekick server is expected to be listening.</span>

<span class="sd">    You **must** call this function *before* creating any Sidekick modules</span>
<span class="sd">    (like `sidekick.Grid()`) or calling any other Sidekick function that might</span>
<span class="sd">    trigger a connection attempt (like `sidekick.clear_all()`). The library uses</span>
<span class="sd">    the URL set here when it makes its first connection attempt.</span>

<span class="sd">    Calling this after a connection attempt has already started (even if it failed)</span>
<span class="sd">    will log a warning and have no effect, unless you explicitly call</span>
<span class="sd">    `sidekick.shutdown()` first to completely reset the connection state.</span>

<span class="sd">    Args:</span>
<span class="sd">        url (str): The full WebSocket URL, which must start with &quot;ws://&quot; or &quot;wss://&quot;.</span>
<span class="sd">            The default value is &quot;ws://localhost:5163&quot;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the provided URL does not start with &quot;ws://&quot; or &quot;wss://&quot;.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import sidekick</span>
<span class="sd">        &gt;&gt;&gt; # If the Sidekick server is running on a different machine or port</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     sidekick.set_url(&quot;ws://192.168.1.100:5163&quot;)</span>
<span class="sd">        ... except ValueError as e:</span>
<span class="sd">        ...     print(e)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Now it&#39;s safe to create Sidekick modules</span>
<span class="sd">        &gt;&gt;&gt; console = sidekick.Console()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_url</span>
    <span class="c1"># Acquire lock for safe state checking and modification.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only allow changing the URL if we are fully disconnected.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot change Sidekick URL after a connection attempt &quot;</span>
                           <span class="s2">&quot;has been made. Call sidekick.shutdown() first if you need to change the URL.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Basic validation for the URL format.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&quot;ws://&quot;</span><span class="p">,</span> <span class="s2">&quot;wss://&quot;</span><span class="p">)):</span>
             <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid WebSocket URL provided: &#39;</span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&#39;. It must be a string &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;starting with &#39;ws://&#39; or &#39;wss://&#39;. Keeping previous URL (&#39;</span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">&#39;).&quot;</span><span class="p">)</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="c1"># Raise error for invalid URL format</span>
        <span class="n">_ws_url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick WebSocket URL set to: </span><span class="si">{</span><span class="n">_ws_url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_config">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.set_config">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_config</span><span class="p">(</span><span class="n">clear_on_connect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">clear_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configures automatic clearing behavior for the Sidekick UI panel.</span>

<span class="sd">    Like `set_url`, you **must** call this function *before* the first connection</span>
<span class="sd">    attempt is made (i.e., before creating any Sidekick modules). Calling it later</span>
<span class="sd">    will have no effect unless `shutdown()` is called first.</span>

<span class="sd">    Args:</span>
<span class="sd">        clear_on_connect (bool): If True (the default), the library will automatically</span>
<span class="sd">            send a command to clear *all* existing elements from the Sidekick UI panel</span>
<span class="sd">            as soon as the connection becomes fully ready (i.e., when the UI panel</span>
<span class="sd">            signals it&#39;s online and ready). This provides a clean slate for your</span>
<span class="sd">            script. Set this to False if you want your script to potentially add to</span>
<span class="sd">            or interact with UI elements left over from a previous script run (less common).</span>
<span class="sd">        clear_on_disconnect (bool): If True (default is False), the library will</span>
<span class="sd">            *attempt* (on a best-effort basis) to send a command to clear the Sidekick</span>
<span class="sd">            UI when your script disconnects cleanly. This happens when `shutdown()`</span>
<span class="sd">            is called explicitly or when the script exits normally (due to the `atexit`</span>
<span class="sd">            handler). This cleanup might *not* happen if the connection is lost</span>
<span class="sd">            abruptly or due to an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_clear_on_connect</span><span class="p">,</span> <span class="n">_clear_on_disconnect</span>
    <span class="c1"># Acquire lock for safe state checking and modification.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only allow changing config if we are fully disconnected.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot change Sidekick config after a connection attempt &quot;</span>
                           <span class="s2">&quot;has been made. Call sidekick.shutdown() first if needed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">_clear_on_connect</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">clear_on_connect</span><span class="p">)</span> <span class="c1"># Ensure boolean type</span>
        <span class="n">_clear_on_disconnect</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">clear_on_disconnect</span><span class="p">)</span> <span class="c1"># Ensure boolean type</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sidekick config set: clear_on_connect=</span><span class="si">{</span><span class="n">_clear_on_connect</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;clear_on_disconnect=</span><span class="si">{</span><span class="n">_clear_on_disconnect</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="activate_connection">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.activate_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">activate_connection</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures the connection to Sidekick is established and fully ready. (Internal use).</span>

<span class="sd">    This function is the gateway for all communication. It&#39;s called implicitly by</span>
<span class="sd">    `send_message` (which is used by all module methods like `grid.set_color`) and</span>
<span class="sd">    at the start of `run_forever`. You generally don&#39;t need to call it directly.</span>

<span class="sd">    It performs the crucial steps of:</span>

<span class="sd">    1. Checking the current connection status.</span>
<span class="sd">    2. If disconnected, initiating the connection attempt (`_ensure_connection`).</span>
<span class="sd">    3. **Blocking** execution if the WebSocket is connected but the UI panel hasn&#39;t</span>
<span class="sd">       signaled readiness yet (waiting on `_ready_event`).</span>
<span class="sd">    4. Returning only when the status is `CONNECTED_READY`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the initial WebSocket connection attempt fails.</span>
<span class="sd">        SidekickTimeoutError: If the connection to the server succeeds, but the Sidekick</span>
<span class="sd">                              UI panel doesn&#39;t signal readiness within the timeout period.</span>
<span class="sd">        SidekickDisconnectedError: If the connection state becomes invalid or disconnected</span>
<span class="sd">                                   during the activation process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Acquire lock to safely check status and potentially initiate connection.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">current_status</span> <span class="o">=</span> <span class="n">_connection_status</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;activate_connection called. Current status: </span><span class="si">{</span><span class="n">current_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># If already fully ready, nothing more to do.</span>
        <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection already READY.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># If disconnected, need to start the connection process.</span>
        <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># _ensure_connection attempts connection, starts listener, sends announce.</span>
                <span class="c1"># Raises SidekickConnectionRefusedError on immediate failure.</span>
                <span class="n">_ensure_connection</span><span class="p">()</span>
                <span class="c1"># If successful, status becomes CONNECTED_WAITING_SIDEKICK.</span>
                <span class="c1"># We now need to wait for the UI&#39;s signal outside the lock.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initial connection attempt successful, proceed to wait for UI readiness.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># If _ensure_connection failed, log and re-raise the specific error.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial connection failed during activate_connection: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># If status is CONNECTING or CONNECTED_WAITING_SIDEKICK, fall through to the wait phase.</span>

    <span class="c1"># --- Wait for READY state (Outside the main lock) ---</span>
    <span class="c1"># Release the lock *before* waiting on the event. This is essential to allow</span>
    <span class="c1"># the listener thread (which needs the lock to update the status and set the event)</span>
    <span class="c1"># to make progress.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting up to </span><span class="si">{</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="si">}</span><span class="s2">s for Sidekick UI readiness signal (_ready_event)...&quot;</span><span class="p">)</span>

    <span class="c1"># Block the current (main) thread until the listener thread calls _ready_event.set()</span>
    <span class="c1"># OR the timeout (_SIDEKICK_WAIT_TIMEOUT) expires.</span>
    <span class="n">ready_signal_received</span> <span class="o">=</span> <span class="n">_ready_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="p">)</span>

    <span class="c1"># --- Check Status *After* Waiting (Re-acquire lock) ---</span>
    <span class="c1"># Re-acquire the lock to safely check the final connection status after the wait.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Case 1: Success! The event was set, and the status confirms we are ready.</span>
        <span class="k">if</span> <span class="n">ready_signal_received</span> <span class="ow">and</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sidekick connection is now confirmed READY.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="c1"># Connection activated successfully.</span>

        <span class="c1"># Case 2: Timeout! The event was *not* set within the time limit.</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ready_signal_received</span><span class="p">:</span>
            <span class="n">timeout_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Timed out waiting for Sidekick UI readiness signal after </span><span class="si">{</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="si">}</span><span class="s2">s&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">timeout_reason</span><span class="p">)</span>
            <span class="c1"># Since the UI never responded, clean up the partially established connection.</span>
            <span class="c1"># Trigger cleanup in a separate thread to avoid potential deadlocks.</span>
            <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">timeout_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="c1"># Raise the specific timeout error for the user.</span>
            <span class="k">raise</span> <span class="n">SidekickTimeoutError</span><span class="p">(</span><span class="n">_SIDEKICK_WAIT_TIMEOUT</span><span class="p">)</span>

        <span class="c1"># Case 3: Inconsistency. The event *was* set, but the status is *not* READY.</span>
        <span class="c1"># This is rare but could happen if the connection dropped immediately after the</span>
        <span class="c1"># listener set the event but before this thread could re-acquire the lock and check.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ready_signal_received is True, but _connection_status is not CONNECTED_READY</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Connection state inconsistent after wait: Ready event was set, but status is now </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connection activation failed: </span><span class="si">{</span><span class="n">disconnect_reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># If not already disconnected, trigger cleanup.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                 <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="c1"># Raise a generic disconnected error.</span>
            <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="send_message">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.send_message">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">send_message</span><span class="p">(</span><span class="n">message_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a command message (as a dictionary) to the Sidekick UI. (Internal use).</span>

<span class="sd">    This is the core function used by all Sidekick modules (`Grid`, `Console`, etc.)</span>
<span class="sd">    to send their specific commands (like &#39;setColor&#39;, &#39;append&#39;, &#39;add&#39;) to the UI panel.</span>
<span class="sd">    You typically don&#39;t call this directly.</span>

<span class="sd">    It ensures the connection is ready via `activate_connection()` before attempting</span>
<span class="sd">    to serialize the message to JSON and send it over the WebSocket.</span>

<span class="sd">    Args:</span>
<span class="sd">        message_dict (Dict[str, Any]): A Python dictionary representing the message.</span>
<span class="sd">            It must conform to the Sidekick communication protocol structure, including</span>
<span class="sd">            `module`, `type`, `target`/`src`, and a `payload` whose keys should generally</span>
<span class="sd">            be `camelCase`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionRefusedError: If the connection isn&#39;t ready and fails during activation.</span>
<span class="sd">        SidekickTimeoutError: If waiting for the UI times out during activation.</span>
<span class="sd">        SidekickDisconnectedError: If the connection is lost *before* or *during* the send attempt.</span>
<span class="sd">        TypeError: If `message_dict` is not a dictionary.</span>
<span class="sd">        Exception: For other unexpected errors (e.g., JSON serialization failure).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;message_dict must be a dictionary&quot;</span><span class="p">)</span>

    <span class="c1"># 1. Ensure connection is fully ready. This blocks or raises errors if necessary.</span>
    <span class="n">activate_connection</span><span class="p">()</span> <span class="c1"># Raises SidekickConnectionError subclasses on failure.</span>

    <span class="c1"># 2. Acquire lock for safe access to the WebSocket object for sending.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">_ws_connection</span>
        <span class="c1"># Double-check status *after* acquiring the lock, as a safety measure against</span>
        <span class="c1"># rare race conditions where the connection might drop between activate_connection returning</span>
        <span class="c1"># and this lock being acquired.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ws</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ws</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
            <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Connection became invalid (</span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) immediately before sending&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>
            <span class="c1"># If not already disconnected, trigger cleanup.</span>
            <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                 <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>

        <span class="c1"># 3. Attempt the send using the internal raw helper.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># _send_raw handles JSON conversion and raises SidekickDisconnectedError on WebSocket errors.</span>
            <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">message_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SidekickDisconnectedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># If _send_raw indicated a disconnection, log it and initiate cleanup.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Send message failed due to disconnection: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
             <span class="c1"># Trigger cleanup if not already disconnected.</span>
             <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                  <span class="c1"># Use a thread for cleanup to avoid potential deadlocks.</span>
                  <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Send failed: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
             <span class="c1"># Re-raise the error to inform the caller (e.g., the Grid method).</span>
             <span class="k">raise</span> <span class="n">e</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># Catch other unexpected errors during send (e.g., JSON serialization).</span>
             <span class="n">disconnect_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unexpected error during send: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span>
             <span class="c1"># Assume connection is compromised, trigger cleanup.</span>
             <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                  <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">close_connection</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disconnect_reason</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
             <span class="c1"># Wrap the error.</span>
             <span class="k">raise</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">disconnect_reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="clear_all">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.clear_all">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clear_all</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends a command to remove *all* visual elements from the Sidekick panel.</span>

<span class="sd">    This effectively resets the Sidekick UI, removing any Grids, Consoles, Viz panels,</span>
<span class="sd">    Canvases, or Controls that were created by *this* running Python script instance.</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionError (or subclass): If the connection is not ready or</span>
<span class="sd">                                              if sending the command fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Requesting global clearAll of Sidekick UI elements.&quot;</span><span class="p">)</span>
    <span class="c1"># Construct the specific &#39;global/clearAll&#39; message according to the protocol.</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="c1"># Target the global scope, not a specific module instance.</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;clearAll&quot;</span><span class="p">,</span>
        <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="kc">None</span>     <span class="c1"># No additional data needed for this command.</span>
    <span class="p">}</span>
    <span class="c1"># Use the public send_message function, which handles readiness checks and errors.</span>
    <span class="n">send_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="close_connection">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.close_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">close_connection</span><span class="p">(</span><span class="n">log_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Closes the WebSocket connection and cleans up resources. (Internal use).</span>

<span class="sd">    This is the core cleanup function. It stops the listener thread, closes the</span>
<span class="sd">    WebSocket socket, sends final &#39;offline&#39;/&#39;clearAll&#39; messages (best-effort),</span>
<span class="sd">    and resets internal state variables.</span>

<span class="sd">    It&#39;s called automatically by `shutdown()` and the `atexit` handler for clean</span>
<span class="sd">    exits, and also triggered internally by the listener thread or `send_message`</span>
<span class="sd">    if an unrecoverable error (`is_exception=True`) is detected.</span>

<span class="sd">    **Users should typically call `sidekick.shutdown()` instead of this directly.**</span>

<span class="sd">    Args:</span>
<span class="sd">        log_info (bool): If True, logs status messages during the closure process.</span>
<span class="sd">        is_exception (bool): If True, indicates this closure was triggered by an</span>
<span class="sd">                             error condition (e.g., listener crash, send failure).</span>
<span class="sd">                             This may influence whether a final `SidekickDisconnectedError`</span>
<span class="sd">                             is raised after cleanup, depending on whether a clean</span>
<span class="sd">                             `shutdown()` was also requested concurrently.</span>
<span class="sd">        reason (str): Optional description of why the connection is closing, used</span>
<span class="sd">                      for logging and potentially included in error messages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ws_connection</span><span class="p">,</span> <span class="n">_listener_thread</span><span class="p">,</span> <span class="n">_listener_started</span><span class="p">,</span> <span class="n">_connection_status</span><span class="p">,</span> <span class="n">_message_handlers</span><span class="p">,</span> <span class="n">_sidekick_peers_online</span>

    <span class="n">disconnect_exception_to_raise</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SidekickDisconnectedError</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Prepare potential exception</span>

    <span class="c1"># Acquire lock for safe modification of shared state during cleanup.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Prevent redundant close operations if already disconnected.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection already closed or closing.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closing Sidekick WebSocket connection... (Exception: </span><span class="si">{</span><span class="n">is_exception</span><span class="si">}</span><span class="s2">, Reason: &#39;</span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>
        <span class="n">initial_status</span> <span class="o">=</span> <span class="n">_connection_status</span> <span class="c1"># Remember status before changing it for logic below.</span>

        <span class="c1"># --- 1. Signal Listener Thread to Stop ---</span>
        <span class="n">_stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span> <span class="c1"># Tell the _listen_for_messages loop to exit.</span>
        <span class="n">_ready_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Connection is no longer ready.</span>

        <span class="c1"># --- 2. Update Internal State Immediately ---</span>
        <span class="n">_connection_status</span> <span class="o">=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="n">_sidekick_peers_online</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Stop tracking UI peers.</span>

        <span class="c1"># --- 3. Best-Effort Cleanup Messages ---</span>
        <span class="c1"># Attempt to send final messages (&#39;clearAll&#39; if configured, &#39;offline&#39; announce)</span>
        <span class="c1"># ONLY if this is a clean shutdown (not an error) AND we were actually connected.</span>
        <span class="c1"># These are best-effort and might fail if the connection is already broken.</span>
        <span class="n">ws_temp</span> <span class="o">=</span> <span class="n">_ws_connection</span> <span class="c1"># Get reference under lock</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_exception</span> <span class="ow">and</span> <span class="n">ws_temp</span> <span class="ow">and</span> <span class="n">ws_temp</span><span class="o">.</span><span class="n">connected</span> <span class="ow">and</span> <span class="n">initial_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTING</span><span class="p">:</span>
             <span class="c1"># Send clearAll if configured for disconnect.</span>
             <span class="k">if</span> <span class="n">_clear_on_disconnect</span><span class="p">:</span>
                  <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempting to send global/clearAll on disconnect (best-effort).&quot;</span><span class="p">)</span>
                  <span class="n">clear_all_msg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;clearAll&quot;</span><span class="p">,</span> <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
                  <span class="k">try</span><span class="p">:</span> <span class="n">_send_raw</span><span class="p">(</span><span class="n">ws_temp</span><span class="p">,</span> <span class="n">clear_all_msg</span><span class="p">)</span>
                  <span class="c1"># Ignore failures here, as connection might be closing.</span>
                  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to send clearAll during disconnect (ignored).&quot;</span><span class="p">)</span>

             <span class="c1"># Send offline announce.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempting to send offline system announce (best-effort).&quot;</span><span class="p">)</span>
             <span class="k">try</span><span class="p">:</span> <span class="n">_send_system_announce</span><span class="p">(</span><span class="s2">&quot;offline&quot;</span><span class="p">)</span>
             <span class="c1"># Ignore failures here as well.</span>
             <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to send offline announce during disconnect (ignored).&quot;</span><span class="p">)</span>

        <span class="c1"># --- 4. Close the WebSocket Socket ---</span>
        <span class="k">if</span> <span class="n">ws_temp</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Give the close operation a short timeout.</span>
                <span class="n">ws_temp</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ws_temp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="c1"># Log errors during close but continue cleanup.</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error occurred during WebSocket close(): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Clear the global reference to the connection object.</span>
        <span class="n">_ws_connection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># --- 5. Prepare Exception (if closure was due to an error) ---</span>
        <span class="c1"># If this close was triggered by an error (is_exception=True), create the</span>
        <span class="c1"># exception object now. We will raise it *after* releasing the lock and</span>
        <span class="c1"># joining the listener thread, but only if a clean shutdown wasn&#39;t also requested.</span>
        <span class="k">if</span> <span class="n">is_exception</span><span class="p">:</span>
            <span class="n">disconnect_exception_to_raise</span> <span class="o">=</span> <span class="n">SidekickDisconnectedError</span><span class="p">(</span><span class="n">reason</span> <span class="ow">or</span> <span class="s2">&quot;Connection closed due to an error&quot;</span><span class="p">)</span>

        <span class="c1"># --- 6. Clear Listener Thread References ---</span>
        <span class="c1"># Store reference to potentially running thread for joining outside the lock.</span>
        <span class="n">listener_thread_temp</span> <span class="o">=</span> <span class="n">_listener_thread</span>
        <span class="n">_listener_thread</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Clear global reference.</span>
        <span class="n">_listener_started</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Allow listener to restart if connect is called again.</span>

    <span class="c1"># --- 7. Join Listener Thread (Outside the main lock) ---</span>
    <span class="c1"># Wait for the listener thread to finish its execution cleanly.</span>
    <span class="c1"># This is done outside the lock to avoid deadlocks if the listener needs the lock to exit.</span>
    <span class="k">if</span> <span class="n">listener_thread_temp</span> <span class="ow">and</span> <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Waiting for listener thread to stop...&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Wait a bit longer than the listener&#39;s receive timeout.</span>
            <span class="n">join_timeout</span> <span class="o">=</span> <span class="n">_LISTENER_RECV_TIMEOUT</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">join_timeout</span><span class="p">)</span>
            <span class="c1"># Check if it actually stopped.</span>
            <span class="k">if</span> <span class="n">listener_thread_temp</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Listener thread did not stop gracefully after join timeout (</span><span class="si">{</span><span class="n">join_timeout</span><span class="si">}</span><span class="s2">s).&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">log_info</span><span class="p">:</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Listener thread stopped.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error joining listener thread: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">log_info</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Listener thread was not running or already finished.&quot;</span><span class="p">)</span>

    <span class="c1"># --- 8. Clear Instance Message Handlers ---</span>
    <span class="c1"># Do this after the listener is stopped, outside the main lock.</span>
    <span class="k">if</span> <span class="n">_message_handlers</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clearing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">_message_handlers</span><span class="p">)</span><span class="si">}</span><span class="s2"> instance message handlers.&quot;</span><span class="p">)</span>
        <span class="n">_message_handlers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">log_info</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick WebSocket connection closed and resources cleaned up.&quot;</span><span class="p">)</span>

    <span class="c1"># --- 9. Raise Exception (if applicable) ---</span>
    <span class="c1"># If this cleanup was triggered by an error (`is_exception` was True),</span>
    <span class="c1"># check if a clean shutdown was *also* requested concurrently (e.g., via Ctrl+C</span>
    <span class="c1"># setting _shutdown_event). If NOT requested, raise the disconnect error now</span>
    <span class="c1"># to signal the problem to the main thread.</span>
    <span class="k">if</span> <span class="n">disconnect_exception_to_raise</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Raising disconnect exception after cleanup: </span><span class="si">{</span><span class="n">disconnect_exception_to_raise</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">disconnect_exception_to_raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If a clean shutdown was requested, don&#39;t raise the error, just log it.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Suppressed disconnect exception because clean shutdown was also requested: </span><span class="si">{</span><span class="n">disconnect_exception_to_raise</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="run_forever">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.run_forever">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_forever</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Keeps your Python script running indefinitely to handle Sidekick UI events.</span>

<span class="sd">    If your script needs to react to interactions in the Sidekick panel (like</span>
<span class="sd">    button clicks, grid cell clicks, console input, etc.), it needs to stay</span>
<span class="sd">    alive to listen for those events. Calling `sidekick.run_forever()` at the</span>
<span class="sd">    end of your script achieves this.</span>

<span class="sd">    It essentially pauses the main thread of your script in a loop, while the</span>
<span class="sd">    background listener thread (managed internally) continues to receive messages</span>
<span class="sd">    from Sidekick and trigger your registered callback functions (e.g., the</span>
<span class="sd">    functions passed to `grid.on_click()` or `console.on_input_text()`).</span>

<span class="sd">    How to Stop `run_forever()`:</span>

<span class="sd">    1. Press `Ctrl+C` in the terminal where your script is running.</span>
<span class="sd">    2. Call `sidekick.shutdown()` from within one of your callback functions</span>
<span class="sd">       (e.g., have a &quot;Quit&quot; button call `sidekick.shutdown` in its `on_click` handler).</span>
<span class="sd">    3. If the connection to Sidekick breaks unexpectedly, `run_forever()` will</span>
<span class="sd">       also stop (typically after a `SidekickDisconnectedError` is raised).</span>

<span class="sd">    Raises:</span>
<span class="sd">        SidekickConnectionError (or subclass): If the initial connection to Sidekick</span>
<span class="sd">            cannot be established when `run_forever` starts. The script won&#39;t enter</span>
<span class="sd">            the waiting loop if it can&#39;t connect first.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import sidekick</span>
<span class="sd">        &gt;&gt;&gt; console = sidekick.Console(show_input=True)</span>
<span class="sd">        &gt;&gt;&gt; def handle_input(text):</span>
<span class="sd">        ...     if text.lower() == &#39;quit&#39;:</span>
<span class="sd">        ...         console.print(&quot;Exiting...&quot;)</span>
<span class="sd">        ...         sidekick.shutdown() # Stop run_forever from callback</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...         console.print(f&quot;You typed: {text}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; console.input_text_handler(handle_input)</span>
<span class="sd">        &gt;&gt;&gt; console.print(&quot;Enter text or type &#39;quit&#39; to exit.&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Keep script running to listen for input</span>
<span class="sd">        &gt;&gt;&gt; sidekick.run_forever()</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;Script has finished.&quot;) # This line runs after run_forever exits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Ensure connection is established and ready before entering the loop.</span>
    <span class="c1">#    This will block or raise connection errors if it fails.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">activate_connection</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">SidekickConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot start run_forever: Initial connection failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Re-raise the error; don&#39;t proceed if we can&#39;t connect.</span>
        <span class="k">raise</span> <span class="n">e</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick entering run_forever mode. Press Ctrl+C or call sidekick.shutdown() to exit.&quot;</span><span class="p">)</span>
    <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Ensure the shutdown signal is clear before starting the loop.</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># --- Main Waiting Loop ---</span>
        <span class="c1"># Loop indefinitely as long as the shutdown event hasn&#39;t been signaled.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="c1"># Wait for the shutdown signal. The `wait()` method blocks until the</span>
            <span class="c1"># event is set or the timeout expires. Using a timeout allows the loop</span>
            <span class="c1"># to periodically check other conditions (like connection status) if needed.</span>
            <span class="c1"># A timeout of 1 second is reasonable.</span>
            <span class="n">shutdown_signaled</span> <span class="o">=</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shutdown_signaled</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Shutdown event detected.&quot;</span><span class="p">)</span>
                <span class="k">break</span> <span class="c1"># Exit the loop cleanly.</span>

            <span class="c1"># Optional check: If the connection status changed (e.g., listener detected</span>
            <span class="c1"># a disconnect), exit the loop early. The actual SidekickDisconnectedError</span>
            <span class="c1"># is typically raised by the listener thread initiating close_connection,</span>
            <span class="c1"># but this check helps exit the wait loop sooner.</span>
            <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">CONNECTED_READY</span><span class="p">:</span>
                      <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run_forever: Connection status changed unexpectedly to </span><span class="si">{</span><span class="n">_connection_status</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">. Exiting loop.&quot;</span><span class="p">)</span>
                      <span class="k">break</span>

    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="c1"># User pressed Ctrl+C in the terminal.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;KeyboardInterrupt received, initiating Sidekick shutdown.&quot;</span><span class="p">)</span>
        <span class="c1"># The `finally` block will handle calling shutdown().</span>
        <span class="k">pass</span> <span class="c1"># Absorb the KeyboardInterrupt here</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch any other unexpected error during the wait loop itself.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error during run_forever wait loop: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Let the `finally` block handle shutdown.</span>
        <span class="k">pass</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># --- Cleanup ---</span>
        <span class="c1"># This block executes regardless of how the loop was exited</span>
        <span class="c1"># (shutdown signal, Ctrl+C, error, or connection status change).</span>
        <span class="c1"># Check if a clean shutdown was *already* signaled (e.g., by a callback).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="c1"># If not, it means we exited for another reason (Ctrl+C, error, disconnect).</span>
            <span class="c1"># Initiate a clean shutdown now.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Loop exited without explicit shutdown signal, initiating shutdown now.&quot;</span><span class="p">)</span>
            <span class="n">shutdown</span><span class="p">()</span> <span class="c1"># Call the standard shutdown procedure.</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="c1"># If shutdown was already signaled, just log that we&#39;re exiting cleanly.</span>
             <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run_forever: Exiting cleanly due to prior shutdown signal.&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick run_forever mode finished.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="shutdown">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.shutdown">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shutdown</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initiates a clean shutdown of the Sidekick connection and resources.</span>

<span class="sd">    Call this function to gracefully disconnect from the Sidekick panel. It performs</span>
<span class="sd">    the following actions:</span>
<span class="sd">    - Signals `run_forever()` (if it&#39;s currently running) to stop its waiting loop.</span>
<span class="sd">    - Attempts to send a final &#39;offline&#39; announcement to the Sidekick server.</span>
<span class="sd">    - Attempts to send a &#39;clearAll&#39; command to the UI (if configured via `set_config`).</span>
<span class="sd">    - Closes the underlying WebSocket connection.</span>
<span class="sd">    - Stops the background listener thread.</span>
<span class="sd">    - Clears internal state and message handlers.</span>

<span class="sd">    It&#39;s safe to call this function multiple times; subsequent calls after the</span>
<span class="sd">    first successful shutdown will have no effect.</span>

<span class="sd">    This function is also registered automatically via `atexit` to be called when</span>
<span class="sd">    your Python script exits normally, ensuring cleanup happens if possible.</span>

<span class="sd">    You might call this manually from an event handler (e.g., a &quot;Quit&quot; button&#39;s</span>
<span class="sd">    `on_click` callback) to programmatically stop `run_forever()` and end the script.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; def on_quit_button_click(control_id):</span>
<span class="sd">        ...    print(&quot;Quit button clicked. Shutting down.&quot;)</span>
<span class="sd">        ...    sidekick.shutdown()</span>
<span class="sd">        &gt;&gt;&gt; controls.add_button(&quot;quit&quot;, &quot;Quit&quot;)</span>
<span class="sd">        &gt;&gt;&gt; controls.on_click(on_quit_button_click)</span>
<span class="sd">        &gt;&gt;&gt; sidekick.run_forever()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Acquire lock briefly to check status and set the shutdown event.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Check if already disconnected or if shutdown is already in progress.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">==</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span> <span class="ow">and</span> <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shutdown already completed or in progress.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Sidekick shutdown requested.&quot;</span><span class="p">)</span>
        <span class="c1"># Signal that a clean shutdown is intended.</span>
        <span class="c1"># This tells run_forever() to exit and prevents close_connection from</span>
        <span class="c1"># raising a disconnect error if called concurrently due to an error.</span>
        <span class="n">_shutdown_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="c1"># Initiate the closing process by calling the internal cleanup function.</span>
    <span class="c1"># Do this *outside* the main lock to avoid potential deadlocks.</span>
    <span class="c1"># Mark this as NOT being triggered by an exception (is_exception=False).</span>
    <span class="n">close_connection</span><span class="p">(</span><span class="n">log_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Shutdown requested by user/script&quot;</span><span class="p">)</span></div>



<span class="c1"># --- Registration/Utility Functions (Mostly Internal/Advanced) ---</span>

<div class="viewcode-block" id="register_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.register_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_message_handler</span><span class="p">(</span><span class="n">instance_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Registers a handler function for messages targeted at a specific module instance. (Internal).</span>

<span class="sd">    This is called automatically by `BaseModule.__init__` when a Sidekick module</span>
<span class="sd">    (like `Grid`, `Console`) is created. It maps the module&#39;s unique `instance_id`</span>
<span class="sd">    to its `_internal_message_handler` method.</span>

<span class="sd">    The listener thread uses this mapping to dispatch incoming &#39;event&#39; and &#39;error&#39;</span>
<span class="sd">    messages from the UI to the correct Python object.</span>

<span class="sd">    Args:</span>
<span class="sd">        instance_id (str): The unique ID of the module instance (e.g., &quot;grid-1&quot;).</span>
<span class="sd">        handler (Callable): The function (usually an instance method) to call.</span>
<span class="sd">                            It must accept one argument: the message dictionary.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the provided handler is not a callable function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; must be callable.&quot;</span><span class="p">)</span>
    <span class="c1"># Acquire lock for safe modification of the shared handler dictionary.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Only register if the connection isn&#39;t already fully shut down.</span>
        <span class="c1"># Allows registration even before the connection becomes CONNECTED_READY.</span>
        <span class="k">if</span> <span class="n">_connection_status</span> <span class="o">!=</span> <span class="n">ConnectionStatus</span><span class="o">.</span><span class="n">DISCONNECTED</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering internal message handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="n">_message_handlers</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Avoid registration if shutdown is complete or in progress.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connection closed or closing, handler for &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39; not registered.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="unregister_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.unregister_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unregister_message_handler</span><span class="p">(</span><span class="n">instance_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes the message handler for a specific module instance. (Internal).</span>

<span class="sd">    Called automatically by `BaseModule.remove()` when a module is explicitly</span>
<span class="sd">    removed, and also during the final `close_connection` cleanup to clear all handlers.</span>

<span class="sd">    Args:</span>
<span class="sd">        instance_id (str): The ID of the module instance whose handler should be removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Acquire lock for safe modification of the shared handler dictionary.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="c1"># Use dict.pop() which safely removes the key if it exists, and does nothing otherwise.</span>
        <span class="c1"># Store the popped value (the handler function) temporarily.</span>
        <span class="n">removed_handler</span> <span class="o">=</span> <span class="n">_message_handlers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">instance_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">removed_handler</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unregistered internal message handler for instance &#39;</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span></div>

        <span class="c1"># else:</span>
            <span class="c1"># No need to log if not found, as this is expected during cleanup or if remove() is called twice.</span>
            <span class="c1"># logger.debug(f&quot;No internal message handler found for instance &#39;{instance_id}&#39; to unregister.&quot;)</span>


<div class="viewcode-block" id="register_global_message_handler">
<a class="viewcode-back" href="../../sidekick.html#sidekick.connection.register_global_message_handler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_global_message_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="kc">None</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Registers a single function to receive *all* incoming messages from Sidekick.</span>

<span class="sd">    **Advanced Usage / Debugging:** This function is primarily intended for debugging</span>
<span class="sd">    the communication protocol or building very custom, low-level integrations.</span>
<span class="sd">    The function you provide (`handler`) will be called by the listener thread for</span>
<span class="sd">    *every* message received from the Sidekick server, *before* the message is</span>
<span class="sd">    dispatched to any specific module instance handlers.</span>

<span class="sd">    Warning:</span>
<span class="sd">        The structure and content of messages received here are subject to the</span>
<span class="sd">        internal Sidekick communication protocol and may change between versions.</span>
<span class="sd">        Relying on this for core application logic is generally discouraged.</span>

<span class="sd">    Args:</span>
<span class="sd">        handler (Optional[Callable[[Dict[str, Any]], None]]): The function to call</span>
<span class="sd">            with each raw message dictionary received from the WebSocket. It should</span>
<span class="sd">            accept one argument (the message dict). Pass `None` to remove any</span>
<span class="sd">            currently registered global handler.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the provided handler is not a callable function and not `None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_global_message_handler</span>
    <span class="c1"># Acquire lock for safe modification of the global handler reference.</span>
    <span class="k">with</span> <span class="n">_connection_lock</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove the global handler.</span>
            <span class="k">if</span> <span class="n">_global_message_handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unregistering global message handler.&quot;</span><span class="p">)</span>
                <span class="n">_global_message_handler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="c1"># Set the new global handler.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering global message handler: </span><span class="si">{</span><span class="n">handler</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">_global_message_handler</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise error if the provided handler is invalid.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Global message handler must be a callable function or None.&quot;</span><span class="p">)</span></div>


<span class="c1"># --- Automatic Cleanup on Exit ---</span>
<span class="c1"># Register the public shutdown() function to be called automatically when the</span>
<span class="c1"># Python interpreter exits normally (e.g., script finishes, sys.exit()).</span>
<span class="c1"># This ensures a best-effort attempt to close the WebSocket, stop the listener,</span>
<span class="c1"># and send cleanup messages like &#39;offline&#39; or &#39;clearAll&#39;.</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">shutdown</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Enjan Chou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>